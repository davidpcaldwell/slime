<!--
LICENSE
This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not
distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.

END LICENSE
-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:jsapi="http://www.inonit.com/jsapi">
<head>
	<title>Java host objects</title>
	<link rel="stylesheet" type="text/css" href="../../loader/api/api.css"></link>
	<script type="text/javascript" src="../../loader/api/api.js"></script>
</head>
<body>
	<script type="application/x.jsapi#initialize"><![CDATA[
		scope.module = $jsapi.environment.module;
		if (!scope.module) {
			//	Compatibility with old test structure
			scope.module = $jsapi.loader.module("module.js", { $slime: jsh.unit.$slime });
		}
		//	'isRhino' seems to be used in the invoked files
		scope.isRhino = typeof(Packages.org.mozilla.javascript.Context) == "function"
			&& (Packages.org.mozilla.javascript.Context.getCurrentContext() != null);
		//	'api' seems to be used in the invoked files
		scope.api = { java: scope.module };
	]]></script>
	<div>
		<h1>Context</h1>
		<ul>
			<li class="value">
				<div class="name">globals</div>
				<!--	<span class="type"></span>	-->
				<span>If <code>true</code>, this module modifies global JavaScript objects.</span>
			</li>
		</ul>
	</div>
	<div>
		<h1>Exports</h1>
		<ul>
			<li class="object">
				<div class="name">Thread</div>
				<div class="label">has properties:</div>
				<ul>
					<li class="constructor" jsapi:id="Task">
						<div class="name">Task</div>
						<script type="application/x.jsapi#initialize">
							var module = scope.module;
							var $$api;
							$jsapi.loader.eval("../../loader/$api.js", {
								$slime: {
									getRuntimeScript: function(path) {
										return {
											name: path,
											js: $jsapi.loader.string("../../loader/" + path)
										}
									}
								},
								//	TODO	dubious; relies on $engine/$platform compatibility
								$engine: $platform,
								$export: function(value) {
									$$api = value;
								}
							});
							scope.$$api = $$api;

							var monitor = new module.Thread.Monitor();

							scope.monitor = monitor;

							var Multithreaded = function(step) {
								var Event = function(f) {
									return function(error,returned) {
										monitor.Waiter({
											until: function() {
												return true;
											},
											then: function() {
												f();
											}
										})();
									}
								};

								return {
									toString: function() {
										return step.toString();
									},
									ready: function() {
										return step.ready();
									},
									task: new module.Thread.Task({
										call: Event(step.call)
									})
								};
							}

							scope.A = function(shared) {
								return new Multithreaded({
									ready: function() {
										return true;
									},
									call: function() {
										shared.a = true;
									}
								});
							};
							scope.B = function(shared) {
								return new Multithreaded({
									ready: function() {
										return shared.a;
									},
									call: function() {
										shared.b = true;
									}
								});
							};
							scope.C = function(shared) {
								return new Multithreaded({
									toString: function() {
										return "C";
									},
									ready: function() {
										return false;
									},
									call: function() {
										throw new Error();
									}
								});
							};
						</script>
						<script type="application/x.jsapi#tests">
							Packages.java.lang.System.err.println("Second test.");
							var Steps = function() {
								var shared = { a: false, b: false };

								this.shared = shared;
								this.c = new C(shared);

								this.steps = [new A(shared), new B(shared), this.c];

								var unready = [];

								this.unready = unready;

								this.on = {
									unready: function(e) {
										unready.push(e.detail);
									}
								}
							};

							var steps = new Steps();

							var task = $$api.threads.steps.Task(steps);

							var finished = false;

							task(monitor.Waiter({
								until: function() {
									return true;
								},
								then: function() {
									finished = true;
								}
							}));

							monitor.Waiter({
								until: function() {
									return finished;
								},
								then: function() {
								}
							})();

							verify(steps).shared.a.is(true);
							verify(steps).shared.b.is(true);
							verify(steps).unready.length.is(1);
							//	TODO	verify(unready[0]).ready.is(steps.c.ready) does not work because ready property of the
							//			verify object does not have is() method. Probably addressable in unit test framework.
							verify(steps).unready[0].is(steps.c);

							var ssteps = new Steps();
							verify(ssteps).shared.a.is(false);

							var stask = $$api.threads.steps.Task(ssteps);

							stask();

							verify(ssteps).shared.a.is(true);
							verify(ssteps).shared.b.is(true);
							verify(ssteps).unready.length.is(1);
							if (ssteps.unready.length) {
								verify(ssteps).unready[0].is(ssteps.c);
							}
						</script>
					</li>
					<li class="function">
						<div class="name">map</div>
						<span>__DESCRIPTION__</span>
						<div class="arguments">
							<div class="label">Arguments</div>
							<ol>
							</ol>
						</div>
						<div class="returns">
							<div class="label">Returns</div>
							<span class="type">__TYPE__</span>
							<span>__DESCRIPTION__</span>
						</div>
						<script type="application/x.jsapi#tests">
							var array = [1,2,3];
							var doubled = module.Thread.map(array,function(element) {
								return element * 2;
							},null,{
								limit: 2,
								callback: function(result) {
									if (result.threw) {
										jsh.shell.console(result.index + "/" + result.threw.type + ": " + result.threw.message);
										jsh.shell.console(result.stack);
									} else {
										jsh.shell.console(result.index + "/" + result.returned);
									}
								}
							});
							verify(doubled)[0].is(2);
							verify(doubled)[1].is(4);
							verify(doubled)[2].is(6);
						</script>
					</li>
					<li class="function">
						<div class="name">forkJoin</div>
						<span>__DESCRIPTION__</span>
						<div class="arguments">
							<div class="label">Arguments</div>
							<ol>
							</ol>
						</div>
						<div class="returns">
							<div class="label">Returns</div>
							<span class="type">__TYPE__</span>
							<span>__DESCRIPTION__</span>
						</div>
						<script type="application/x.jsapi#tests">
							var fork = [
								(function() { return 1; }),
								(function() { return 3; }),
								(function() { return 2; })
							];
							var result = module.Thread.forkJoin(fork);
							verify(result).length.is(3);
							verify(result)[0].is(1);
							verify(result)[1].is(3);
							verify(result)[2].is(2);
						</script>
					</li>
				</ul>
				<script type="application/x.jsapi#tests">
					if (module.Thread) {
						var sleeper = function(length) {
							return function() {
								Packages.java.lang.Thread.sleep(length);
							}
						}

						var f = function() {
							Packages.java.lang.Thread.sleep(100);
							return 1;
						};

						var Callbacks = function() {
							var result;

							this.result = function(v) {
								result = v;
							};

							this.error = function(t) {
								throw t;
							};

							this.timeout = function() {
								result = "Timed out.";
							}

							this.evaluate = function() {
								return result;
							};

							this.getResult = function() {
								return result;
							}
						};

						var c1 = new Callbacks();
						var t1 = module.Thread.start({
							call: f,
							timeout: 150,
							on: c1
						});
						t1.join();
						test(c1.evaluate() == 1);

						//	This test is highly suspect; it essentially hopes that the CPU scheduling happens as expected. Its
						//	chances of passage could be improved by using thread priorities for timeouts, which is probably a good
						//	idea anyway. But perhaps it needs to be re-designed.
						var c2 = new Callbacks();
						var t2 = module.Thread.start({
							call: sleeper(250),
							timeout: 50,
							on: c2
						});
						t2.join();
						verify(c2).getResult().is("Timed out.");
					}
				</script>
			</li>
			<!--
				Experimental methods

				fail(): no real specification, no unit tests

				$doc.members.isJavaType = new $Doc.Function({
					summary: "Determines whether a value is a Java host object representing the given type or not.",
					asFunction: {
						description: <>Creates a function which can determines whether a value is a Java object of the given type or not</>,
						arguments: {
							list: [
								{ type: "JavaClass", comment: <>A Rhino <code>JavaClass</code> object, like <code>Packages.java.lang.Object</code></> }
							]
						},
						returns: {
							type: "function",
							comment: <>Returns a function which takes a single argument and returns <code>true</code> if the given argument is an object of the given Java type and <code>false</code> if it is not.</>
						}
					}
				});
			-->
			<!--
				//	No unit tests!
				$doc.members.toJavaArray = new $Doc.Function({
					summary: <>Converts an ECMAScript array into a Java array</>,
					asFunction: {
						description: <>Converts an ECMAScript array into a Java array</>,
						arguments: {
							list: [
								{ type: <><code>Array</code></>, comment: <>An array to be converted</> },
								{
									type: <>A Java class reference</>,
									comment: <>A reference to a Java class, e.g., <code>Packages.java.lang.Object</code>, representing the type of
										the array to create</>
								}
							]
						},
						returns: {
							type: "A Java array",
							comment: <>A Java array containing the elements in the ECMAScript array.</>
						}
					}
				});
			-->
		</ul>
	</div>
</body>
</html>
