<!--
LICENSE
This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not
distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.


The Original Code is the SLIME project.

The Initial Developer of the Original Code is David P. Caldwell <david@davidpcaldwell.com>.
Portions created by the Initial Developer are Copyright (C) 2018 the Initial Developer. All Rights Reserved.

Contributor(s):
END LICENSE
-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:jsapi="http://www.inonit.com/jsapi">
	<head>
		<title>SLIME: development</title>
		<link href="../loader/api/api.css" rel="stylesheet" type="text/css" />
		<script>
			window.slime = {
				definition: {
					settings: {
						isHomePage: true
					}
				}
			}
		</script>
		<script src="../loader/api/api.js"></script>
		<script>
			//	TODO	CORS
			document.domain = document.domain;
		</script>
		<style>
			#jsapi table { border-collapse: collapse; }
			#jsapi th, #jsapi td {
				border: 1px solid black;
				padding: 0.5em 1.0em;
			}
			h2 {
				text-decoration: underline;
			}
			.section {
				padding: 0.5em 1em;
				border: 1px solid grey;
			}
		</style>
		<script>
			window.addEventListener("load", function() {
//				document.body.style.backgroundColor = "#c0c0c0";
				/** @type { HTMLElement[] } */
				var elements = Array.prototype.slice.call(document.getElementsByTagName("*"));
				elements.forEach(function(element) {
					var tag = element.tagName.toLowerCase();
					if (tag == "h3" || tag == "h2" || tag == "h4") {
						element.parentElement.className = (element.parentElement.className)
							? element.parentElement.className + " " + "section"
							: "section"
						;
					}
				});
			});
		</script>
	</head>
	<body>
		<h1>SLIME: Contributing</h1>
		<div>This page contains resources for developing SLIME itself.</div>
		<div>
			<h2><a href="../local/doc/typedoc/interfaces/slime.project.wf.interface.html"><code>wf</code> Commands for SLIME itself</a></h2>
		</div>
		<div>
			<h2>Project Management</h2>
			<div>
				GitHub <a href="https://github.com/davidpcaldwell/slime/projects?query=is%3Aopen+sort%3Aname-asc">projects</a> are
				things that can get done; they're releases, as well as projects that are orthogonal to releases and
				<em>that have an endpoint</em>, and a Backlog project for unscheduled items.
				Issues should be assigned to at least one project.
			</div>
			<h3><a href="https://github.com/davidpcaldwell/slime/issues?q=is%3Aissue+is%3Aopen+no%3Aproject">Issues with no assigned project</a></h3>
			<div>
				<h3><a href="https://github.com/davidpcaldwell/slime/projects?query=is%3Aopen+sort%3Aname-asc">Open Projects</a></h3>
				<div id="jsapi">
					<h4><a href="https://github.com/davidpcaldwell/slime/projects/13">jsapi</a>: migrate old tests to Fifty</h4>
					<div>
						The current state of interoperability between the old jsapi tests and the new Fifty tests is as follows:
						<table>
							<thead>
								<tr>
									<th>Parent</th>
									<th>Child</th>
									<th>In-process</th>
									<th>Fork</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>jsapi</td>
									<td>jsapi</td>
									<td>
										Supported in a variety of ways, including <code>jsh.unit.html.Suite</code>
										<code>add()</code>
									</td>
									<td>
										Supported via <code>-stdio</code> protocol
									</td>
								</tr>
								<tr>
									<td>jsapi</td>
									<td>Fifty</td>
									<td>
										<code>$jsapi.loader.fifty({ path: <i>path</i>, verify: verify })</code>
									</td>
									<td>
										The <code>loader/api/test/fifty/test.jsh.js</code> script provides a
										<code>--view jsapi</code> argument that allows the executed Fifty script to broadcast its
										results via <code>stdio</code> in a way compatible with jsapi. For jsapi-based tests, this is encapsulated in
										<code>jsh.unit.fifty.Part(p)</code>, which takes <code>shell</code>, <code>script</code>,
										and <code>file</code> as properties.
									</td>
								</tr>
								<tr>
									<td>Fifty</td>
									<td>jsapi</td>
									<td>No support; jsapi suites can be replaced by Fifty bottom-up</td>
									<td>Minimal support: could read exit status</td>
								</tr>
								<tr>
									<td>Fifty</td>
									<td>Fifty</td>
									<td>
										Fifty kit <a href="../local/doc/typedoc/interfaces/slime.fifty.test.kit.html#load">load()</a>
										methods
									</td>
									<td>
										Minimal support currently: could read exit status. Unclear whether more is needed.
									</td>
								</tr>
							</tbody>
						</table>
					</div>
				</div>
				<div>
					<h4><a href="https://github.com/davidpcaldwell/slime/projects/10">GraalVM</a>: get SLIME running on GraalVM</h4>
					<div>
						To install: from script <code>jsh.shell.tools.graal.install()</code>, or from command line
						<code>./jsh.bash jsh/tools/install/graal.jsh.js</code>.
					</div>
					<div>
						To run sample script:
						<code>env JSH_ENGINE=graal ./jsh.bash jsh/test/jsh-data.jsh.js</code>
					</div>
					<div>
						To run sample script in debugger:
						<code>env JSH_ENGINE=graal JSH_DEBUG_SCRIPT=graal ./jsh.bash jsh/test/jsh-data.jsh.js</code>
					</div>
				</div>
				<div>
					<h4><a href="https://github.com/davidpcaldwell/slime/projects/4">Reorganize source tree</a>: better names in better locations</h4>
				</div>
				<div>
					<h4><a href="https://github.com/davidpcaldwell/slime/projects/7">JCEF</a>: Use an embedded Chromium rather than a forked Chrome for UIs</h4>
				</div>
				<div>
					<h4><a href="../loader/document/api.html">loader/document</a>: improve HTML parsing</h4>
					<div>
						Goal would be to replace DOM in loader/browser/test/api.js and JaspiHtml in jsh/unit/html.js; this feeds into
						loader/api/api.html.js as the <code>html</code> argument to ApiHtmlTests.
					</div>
					<div>
						First step should be to build an adapter at loader/api/document-adapter.js that converts a loader/document
						document into a JSAPI-compatible html object. An additional property can be added to jsh/unit/html.js
						PartDescriptor argument to specify the creation of this new kind of document in loadApiHtml().
					</div>
					<div>
						Test case which runs the above scenario:
						<code>./jsh.bash loader/document/test/suite.jsh.js -experimental -part document</code>
					</div>
					<div>
						An equivalent browser migration for replacing the JSAPI DOM in loader/browser/test/api.js is then needed.
					</div>
					<div>
						<h5><a href="https://jsoup.org/">JSoup</a></h5>
						<a href="https://jsoup.org/apidocs/overview-summary.html">API</a>
					</div>
					<div>
						<h5><a href="../loader/document/source.api.html">Source-level parser</a></h5>
					</div>
				</div>
			</div>
		</div>
		<div>
			<h2>Documentation</h2>
			<div>
				<h3>Low-level structure</h3>
				<div>
					<h4><a href="../local/doc/typedoc/modules/slime.runtime.html">SLIME Runtime</a> (<code><a href="../loader/expression.js">loader/expression.js</a></code>)</h4>
				</div>
				<div>
					<h4><a href="../loader/jrunscript/api.html">SLIME Java runtime</a></h4>
				</div>
			</div>
			<div>
				<h3>Shell: <code>jsh</code></h3>
				<div>
					<h4><a href="../jsh/launcher/internal.api.html">Launcher</a> documentation</h4>
				</div>
				<div>
					<h4><a href="../jsh/loader/internal.api.html">Loader</a> documentation</h4>
				</div>
			</div>
			<div>
				<h3><a href="typescript.api.html">TypeScript integration</a></h3>
			</div>
		</div>
		<div>
			<h2>Testing</h2>
			<div>
				<h3><code><a href="suite.jsh.js">contributor/suite.jsh.js</a></code></h3>
				Runs all tests, installing Tomcat into the shell if necessary so that browser (and servlet) tests can be run.
			</div>
			<div>
				<h3><code>./wf docker.test</code></h3>
				Runs the full test suite in Docker.
			</div>
			<div>
				<h3>Suite parts</h3>
				The suite runs:
				<ul>
					<li><code><a href="jrunscript-engines.jsh.js">contributor/jrunscript-engines.jsh.js</a></code>,</li>
					<li><code><a href="jrunscript.jsh.js">contributor/jrunscript.jsh.js</a></code>,</li>
					<li><code><a href="loader/browser/suite.js">loader/browser/suite.js</a></code>,</li>
					<li>A series of tests on development tools.</li>
				</ul>
			</div>
			<div>
				<h3>Running the full browser suite (implemented in jsapi)</h3>
				<div>
					<code>./jsh.bash
						<a href="../loader/browser/test/suite.jsh.api.html">loader/browser/test/suite.jsh.js</a>
						-suite <a href="../loader/browser/suite.js">loader/browser/suite.js</a>
						[-interactive]
					</code>
				</div>
			</div>
			<div>
				<h3>Running <code>jrunscript</code>-based subsuites, in whole or in part</h3>
				<ul>
					<li>
						Java tests:
						<code><a href="jrunscript.jsh.js">contributor/jrunscript.jsh.js</a>
							[-view <i>view</i>]
							[-part <i>suitepath[:pagepath]</i>]
							[-noselfping] [-executable]
						</code>
					</li>
				</ul>
			</div>
			<div>
				<h3>Testing specific features</h3>
				<div>
					<h4>Built <code>jsh</code> shells</h4>
					<div>
						<code>./jsh.bash jsh/test/tools/run-in-built-shell.jsh.js <i>script</i> [<i>arguments</i>]</code>.
					</div>
				</div>
				<div>
					<h4>Testing Remote Shells Using Mock GitHub</h4>
					<div>
						Remote shells, run directly from GitHub, can be "tested" locally using the GitHub mock. This process is
						currently manual:
						<ul>
							<li>
								Execute <code>./jsh.bash rhino/tools/github/test/manual/jsh.jsh.js serve</code>, which will start
								a mock GitHub server and create a <code>curl</code> command to execute the shell remotely, emitting
								that command to the console and (on macOS) copying it to the clipboard.
							</li>
							<li>
								Go to another terminal and execute the <code>curl</code> command emitted to the console, which will
								run the standard <code>jsh</code> diagnostic script. Confirm the script executes correctly.
							</li>
						</ul>
					</div>
					<!--
						Older documentation for the above
						TODO	check to see whether completely obsolete
						TODO	very doubtful the part about private repositories is useful; it probably pertains to Bitbucket
					<div>
						<h3>Provisioning</h3>
						<div>
							<code>jrunscript rhino/jrunscript/api.js jsh jsh/tools/provision/test/server.jsh.js</code>
						</div>
						<div>
							Test: copy and paste the <samp>Testing (standard)</samp> output and make sure it produces a Hello, World message.
						</div>
						<div>
							Testing private repositories requires the private <code>slime-kit</code> repository, and can be invoked as
							follows:
							<div>
								<code>-repository:name slime-kit -repository:location <i>directory where slime-kit is located</i> -repository:script test/provision-script.jsh.js -password <i>password for server to use for davidpcaldwell</i></code>
							</div>
						</div>
					</div>
					-->
					<!--
						More older documentation for the above
					<h4>Remote <code>jsh</code> shells</h4>
					<div>
						See <a href="../jsh/tools/provision/test/plugin.jsh.api.html"><code>jsh.test.provision</code></a>.
					</div>
					-->
				</div>
				<div>
					<h4>Testing native launcher</h4>
					<code>./jsh.bash jsh/test/manual/launcher/native.jsh.js [-java <i>JDK-location</i>] [-rhino <i>rhino-location</i>]</code>
				</div>
				<div>
					<h4>TypeScript runtime integration</h4>
					<div>
						See <code>jsh/tools/test/typescript.jsh.js</code>.
					</div>
				</div>
				<div>
					<h4>Google Chrome integration</h4>
					<div>
						<code>rhino/shell/test/manual/chrome.jsh.js</code>
						<ul>
							<li><code>profile</code></li>
							<li><code>app</code></li>
							<li><code>close [-exitOnClose]</code>: allows testing the detection of Google Chrome closing. On OS X, the
								<code>-exitOnClose</code> flag will attempt to terminate Chrome when the last window for the
								user data directory closes. Upon closure, a message will be printed to the console announcing Chrome
								has closed.
							</li>
						</ul>
					</div>
				</div>
			</div>
			<div>
				<h3>Configuring Supported Test Environments</h3>
				<div>
					<h4>VM Testing</h4>
					<div>
						<h5>Linux: Ubuntu 20.04.2.0 on VMWare</h5>
						<ul>
							<li>VMWare</li>
							<li>Do not use "Easy Install"</li>
							<li>Legacy BIOS</li>
							<li>
								Customize Settings
								<ul>
									<li>Save As: slime-linux</li>
									<li>Sharing
										<ul>
											<li>Enable Shared Folders</li>
											<li>Add source folder with name <code>slime</code> and read/write access</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								Installation Wizard
								<ul>
									<li>
										English | Install Ubuntu
									</li>
									<li>
										English (US) - English (US)
									</li>
									<li>
										Minimal installation; Install third-party software: <strong>true</strong>
									</li>
									<li>
										Erase disk and install Ubuntu
									</li>
									<li>
										Where are you? New York
									</li>
									<li>
										<ul>
											<li>Your name: SLIME Linux Testbed</li>
											<li>Your computer's name: slime-linux</li>
											<li>Pick a user name: slime</li>
											<li>Choose a password: slime</li>
											<li>Confirm your password: slime</li>
											<li>Log in automatically</li>
										</ul>
									</li>
									<li>
										(Remove installation CD and reboot)
									</li>
									<li>
										Connect Your Online Accounts: skip
									</li>
									<li>
										Livepatch: Next
									</li>
									<li>
										Help improve Ubuntu: Yes
									</li>
									<li>
										You're ready to go! Done
									</li>
									<li>
										Install VMWare Tools
										<ul>
											<li>sudo apt install open-vm-tools</li>
											<li>sudo apt install open-vm-tools-desktop</li>
										</ul>
									</li>
									<li>
										Terminal
										<ul>
											<li>sudo apt-get update</li>
											<li>cd /mnt/hgfs/slime</li>
											<li>source contributor/macos/linuxvm/profile.bashrc</li>
											<li>./wf test</li>
										</ul>
									</li>
									<li>
										If <code>hgfs</code> connection is lost somehow, use:
										<div>
											<code>sudo vmhgfs-fuse .host:/ /mnt/hgfs/ -o allow_other -o uid=1000</code>
										</div>
									</li>
								</ul>
							</li>
						</ul>
					</div>
					<div>
						<h5>macOS Big Sur: VMWare</h5>
						<ul>
							<li><a href="https://support.apple.com/en-us/HT201372">Getting the installer application</a></li>
							<li>
								Customize Settings
								<ul>
									<li>Save As: slime-macos</li>
									<li>Sharing
										<ul>
											<li>Enable Shared Folders</li>
											<li>Add source folder with name <code>slime</code> and read/write access</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								Installation Wizard
								<ul>
									<li>Language: English</li>
									<li>Install macOS Big Sur</li>
									<li>Continue</li>
									<li>License: Agree (Confirm Agree)</li>
									<li>Install to Macintosh HD</li>
									<li>Country or Region: United States</li>
									<li>Written and Spoken Languages: defaults</li>
									<li>Accessibility: Not Now</li>
									<li>Data &amp; Privacy: Continue</li>
									<li>Migration Assistant: Not Now</li>
									<li>Sign In with Your Apple ID: Set Up Later, Skip</li>
									<li>Terms and Conditions: Agree, Agree</li>
									<li>Full Name: SLIME macOS Testbed</li>
									<li>Account Name: slime</li>
									<li>Password: slime (Hint: project name)</li>
									<li>Express Set Up: Continue</li>
									<li>Analytics: Share crash and usage data with app developers: CHECKED</li>
									<li>Screen Time: Set Up Later</li>
									<li>Siri: Enable Ask Siri: UNCHECKED</li>
									<li>Choose Your Look: Light</li>
									<li>(on host) Virtual Machine | Install VMWare Tools</li>
									<li>(on guest) Install VMWare Tools</li>
									<li>Open Security Preferences (clock lock)</li>
									<li>System software from developer "VMWare, Inc." was blocked from laoding: Allow | Restart</li>
									<li>(on host) Virtual Machine | Snapshot | Take Snapshot, change name to Stock</li>
									<!--
										Terrible performance; see
										https://communities.vmware.com/t5/VMware-Fusion-Discussions/Abysmal-Performance-in-Fusion-12-after-upgrade-to-macOS-Big-Sur/td-p/2809964

										Tried the following three things, which seemed to have negligible impact:

										<li>(on host) Virtual Machine | Settings | Processors and Memory | 4 cores, 8192MB</li>
										<li>(on host) Virtual Machine | Settings | Advanced | Disable Side Channel Mitigations: CHECKED</li>
										<li>(on host) Virtual Machine | Settings | Compatibility | Use Hardware Version: 16</li>
									-->
								</ul>
							</li>
						</ul>
					</div>
				</div>
				<div>
					<h4>Docker</h4>
					<ul>
						<li>Increase Docker RAM to 4GB</li>
					</ul>
				</div>
				<div>
				</div>
			</div>
		</div>
		<div>
			<h2>Dependencies: updating</h2>
			<div>
				<h3>JDK</h3>
				<div>
					<h4>JDK 8</h4>
					See <a href="https://github.com/corretto/corretto-8/releases">Amazon Corretto 8</a> site and then update
					<code>./jsh.bash</code> in two places (URL and basename).
				</div>
				<div>
					<h4>JDK 11</h4>
					See <a href="https://github.com/corretto/corretto-11/releases">Amazon Corretto 11</a> site and then update
					<code>./jsh.bash</code>.
				</div>
				<div>
					<h4>Old</h4>
					<ul>
						<li>JDK: <code>jsh/tools/provision/jdk.bash</code></li>
					</ul>
				</div>
			</div>
			<div>
				<h3>Rhino</h3>
				<p>
					Rhino is currently downloaded and installed as part of the <code>jrunscript</code> bootstrap API
					(see <a href="../rhino/jrunscript/api.js"><code>rhino/jrunscript/api.js</code></a>, specifically
					<code>$api.rhino.download()</code>)
					in order to
					preserve the ability to restore support for older JDKs (6 or 7, where the built-in engine cannot
					run the loader, so the launcher would need to install it).
				</p>
				<p>
					The implementation could be simplified at the cost of making it harder to restore support for JDK 6 and
					7. Relying on the shell to install Rhino would also increase reliance on the deprecated Nashorn, which
					would be running the shell that installed Rhino.
				</p>
				<p>
					Rhino can be updated by updating the default version in <code>rhino/jrunscript/api.js</code>, along with
					(so that contributors can work properly) the version in <code>build.gradle</code>.
				</p>
			</div>
			<div>
				<h3>Nashorn</h3>
				<p>
					<code>jsh</code> presently depends on the Nashorn bundled with the JDK on which it is running.
				</p>
				<div>
					<h4><code>ncdbg</code></h4>
					<p>
						<strong>Note that no version of <code>ncdbg</code> is currently working with SLIME!</strong>
					</p>
					<p>
						The version of <code>ncdbg</code> is specified in
						<a href="../jsh/tools/install/plugin.jsh.js"><code>jsh/tools/install/plugin.jsh.js</code></a>.
					</p>
				</div>
			</div>
		</div>
		<div>
			<h2>Writing Code</h2>
			<div>
				SLIME uses TypeScript for type definition (a few types are still defined in JavaScript for historical reasons).
				However, the SLIME implementation is written in JavaScript. TypeScript
				information is represented in the code using TypeScript's JSDoc integration.
				See the <a href="https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html#supported-jsdoc">TypeScript documentation</a>
				on using JSDoc to specify TypeScript information for details.
			</div>
		</div>
	</body>
</html>

