<!--
LICENSE
This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not
distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.


The Original Code is the SLIME loader infrastructure.

The Initial Developer of the Original Code is David P. Caldwell <david@davidpcaldwell.com>.
Portions created by the Initial Developer are Copyright (C) 2015 the Initial Developer. All Rights Reserved.

Contributor(s):
END LICENSE
-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:jsapi="http://www.inonit.com/jsapi">
	<head>
		<title>$api</title>
		<link href="api/api.css" rel="stylesheet" type="text/css" />
		<script src="api/api.js"></script>
	</head>
	<body>
		<h1>$api</h1>
		<div jsapi:id="top">
			<script type="application/x.jsapi#initialize">
				var $slime = {
					getLoaderScript: function(path) {
						return {
							name: path,
							code: $jsapi.loader.string(path)
						}
					}
				};
				scope.api = $jsapi.loader.eval("$api.js", { $platform: $platform, $slime: $slime });
				scope.api.loadedByJsapi = true;
			</script>
			<div jsapi:id="summary">
				The <code>$api</code> object is provided to all code loaded by the platform loader. It provides basic JavaScript
				language functionality.
			</div>
			<ul>
				<li class="function" jsapi:id="deprecate">
					<div class="name"><a name="$api.deprecate">deprecate</a></div>
					<span>
						A function that can be used to mark a named property on an object as a deprecated API.
					</span>
					<div class="arguments">
						<div class="label">Arguments</div>
						<ol>
							<li class="value">
								<span class="type">function</span>
								<span>A function to mark.</span>
							</li>
						</ol>
						-or-
						<ol>
							<li class="value">
								<span class="type">object</span>
								<span>A target object whose property will be marked.</span>
							</li>
							<li class="value">
								<span class="type">string</span>
								<span>
									(optional) The name of the property to mark. If omitted, <strong>all</strong> properties will be
									marked.
								</span>
							</li>
						</ol>
					</div>
					<div class="returns">
						<div class="label">Returns</div>
						<span class="type">function</span>
						-or-
						<span class="type">undefined</span>
						<span>
							If the argument was a function, returns a version of the function that is deprecated: that is, executes
							the appropriate warning callback when it is executed. Otherwise, returns undefined.
						</span>
					</div>
					<ul>
						<li class="function">
							<div class="name">warning</div>
							<span>
								(optional) A callback function that will be invoked when a marked property is accessed or marked
								function is called, or when a call to <code>deprecate</code> is made with invalid arguments.
							</span>
							<div class="arguments">
								<div class="label">Arguments</div>
								<ol>
									<li class="object">
										<span>Represents a single usage of a marked API.</span>
										<div class="label">has properties:</div>
										<ul>
											<li class="value">
												<div class="name">reason</div>
												<span class="type">function</span>
												<span>
													The reason that the API was marked: in the case of deprecation, a
													reference to the <code>deprecate</code> function itself.
												</span>
											</li>
											<!--
											TODO	Single-argument form deprecating a function
											<li class="value">
												<div class="name">function</div>
												<span class="type">function</span>
												<span>__DESCRIPTION__</span>
											</li>
											-->
											<li class="value">
												<div class="name">object</div>
												<span class="type">object</span>
												<span>(if object was specified) The object containing the marked property.</span>
											</li>
											<li class="value">
												<div class="name">property</div>
												<span class="type">string</span>
												<span>(if object was specified) The name of the marked property.</span>
											</li>
											<li class="value">
												<div class="name">callee</div>
												<span class="type">function</span>
												<span>(if deprecated item is function) A reference to the deprecated function.</span>
											</li>
											<li class="value">
												<div class="name">target</div>
												<span class="type">object</span>
												<span>
													(if deprecated item is function) The <code>this</code> value when the deprecated
													function was invoked.
												</span>
											</li>

											<li class="value">
												<div class="name">arguments</div>
												<span class="type">Array</span>
												<span>
													(if deprecated item is function) The contents of the <code>arguments</code> object
													passed to the function; note that this object is an array, not the
													<code>arguments</code> object.
												</span>
											</li>
											<li class="value">
												<div class="name">get</div>
												<span>
													(if deprecated item is non-function) The value of the marked property when it was
													accessed, if this usage was
													a retrieval of the value of a marked property.
												</span>
											</li>
											<li class="value">
												<div class="name">set</div>
												<span>
													(if deprecated item is non-function) The value to which the deprecated property was set, if this usage was an
													assignment to a marked property.
												</span>
											</li>
											<li class="value">
												<div class="name">flag</div>
												<span class="type">Array</span>
												<span>
													(when invalid arguments sent to deprecate) The arguments passed to deprecate that
													did not identify a valid function or property to deprecate.
												</span>
											</li>
										</ul>
									</li>
								</ol>
							</div>
						</li>
					</ul>
					<script type="application/x.jsapi#tests">
						verify(api.loadedByJsapi,"$api.loadedByJsapi").is(true);
					</script>
					<script jsapi:id="deprecate.function" type="application/x.jsapi#tests"><![CDATA[
						var called = 0;
						var warnings = 0;
						var f = function() {
							called++;
							return called;
						};
						var warning = function(p) {
							verify(p.callee).is(f);
							warnings++;
						};
						api.deprecate.warning = warning;

						var deprecated = api.deprecate(f);
						verify(f()).is(1);
						verify(warnings).is(0);
						verify(deprecated()).is(2);
						verify(warnings).is(1);
						verify(deprecated()).is(3);
						verify(warnings).is(2);
					]]></script>
					<script jsapi:id="deprecate.object" type="application/x.jsapi#tests"><![CDATA[
						var called = 0;
						var warnings = [];
						var warning = function(p) {
							warnings.push(p);
						}
						api.deprecate.warning = warning;
						var o = new function() {
							this.p = 1;
							this.m = function() {
								return 2;
							};
						};
						verify(api.deprecate(o)).is(void(0));
						var p = o.p;
						verify(p).is(1);
						var m = o.m();
						verify(m).is(2);
						verify(warnings).length.is(2);
						//	TODO	test content of warnings
					]]></script>
					<script jsapi:id="deprecate.properties" type="application/x.jsapi#tests"><![CDATA[
						var f = function() {
							return 8;
						};
						f.property = "foo";

						var o = new function() {
							this.f = f;
						};
						api.deprecate(o, "f");

						var Flagged = function() {
							var warnings = [];

							var callback = function(warning) {
								warnings.push(warning);
							}

							api.deprecate.warning = callback;

							this.warnings = warnings;
						};

						// TODO: right now mere property access to a method does *not* trigger a warning; only invocation does
						verify(f == o.f).is(false);
						var flagged = new Flagged();
						verify(flagged).warnings.length.is(0);
						verify(o).f().is(8);
						verify(flagged).warnings.length.is(1);
						verify(f.property).is("foo");
						verify(o.f.property).is("foo");
					]]></script>
					<script type="application/x.jsapi#tests"><![CDATA[
						var deprecate = api.deprecate;

						//	TODO	Add a test somewhere in here where we attempt to set a deprecated property, do not really
						//			set it, and confirm that our callback receives the attempted (not actual) value
						var expectWarn = function(b) {
							var rv = function(content) {
								if (content.reason != deprecate) throw new Error("Not expected reason.");
								arguments.callee.actual = true;
							}
							rv.actual = false;
							rv.expect = b;
							rv.test = function() {
								return rv.actual == rv.expect;
							}
							rv.evaluate = function(message) {
								var success = this.test();
								var m;
								if (!message) {
									m = (success) ? "expectWarn PASS: expect=" + rv.expect + " actual=" + rv.actual : "expectWarn FAIL: expect=" + rv.expect + " actual=" + rv.actual;
								} else {
									m = (success) ? message + " passed." : message + " FAILED.";
								}
								verify.test(function() {
									return { success: success, message: m };
								});
							}
							api.deprecate.warning = rv;
							//$unit.context.setWarning(rv);
							return rv;
						}

						//	Each test either uses the jsunit Tests object or uses a custom console output
						//	Hook for execution environment to override console function
						var Tests;
//						var test = function(f,message) {
//							scope.test(f);
//						}

						//
						//	Begin tests
						//

						var x = {
							foo: "bar",
							toString: function() {
								return "x1";
							}
						}

						var accessor = $platform && $platform.Object.defineProperty && $platform.Object.defineProperty.accessor;
						if (accessor) {
							deprecate(x,"foo");
							var yes = expectWarn(true);
							var z = x.foo;
							yes.evaluate("get x.foo");
						}
						//test(warning.test);

						//	Should FAIL
						//expectWarn(true);
						//test(warning.test);
						//

						//console("x1.foo = " + x.foo);
						if (accessor) {
							var yes = expectWarn(true);
							x.foo = "baz";
							yes.evaluate();
							verify.test(function() {
								var success = x.foo == "baz";
								var message = (success) ? "Value correct" : "Value " + x.foo;
								return {
									success: success,
									message: message
								}
							});
						}

						var yes = expectWarn(false);
						x.bar = "baz";
						yes.evaluate();

						if (accessor) {
							//console("x1.foo = " + x.foo);
							var x2 = new function() {
								this.foo = "bar";
								this.__defineSetter__("foo", function(value) {
									this.$foo = value;
								} );

								deprecate(this, "foo");
							}

							var yes = expectWarn(true);
							var z = x2.foo;
							yes.evaluate();

							var yes = expectWarn(true);
							x2.foo = "BAR";
							yes.evaluate();
							verify(x2.foo, "foo is still").is(void(0));

							var x3 = new function() {
								this.foo = 0;

								var foo = 0;

								this.__defineGetter__("foo", function() {
									return ++foo;
								} );

								deprecate(this, "foo");
							}

							var yes = expectWarn(true);
							var z = x3.foo;
							yes.evaluate();
							verify(z > 0, "Getter-only value increasing").is(true);
							verify(x3, "Getter-only value increasing").evaluate(function() { return this.foo > z; }).is(true);
//							test(z > 0, "Getter-only value increasing.");
//							test(x3.foo > z, "Getter-only value increasing.");

							var yes = expectWarn(true);
							x3.foo = 11;
							yes.evaluate();
							verify(x3).foo.is.not(11);
//							test(x3.foo != 11, "Cannot re-set once getter defined.");

							x3.__defineGetter__("foo", function() {
								return 42;
							});
							var yes = expectWarn(false);
							var z = x3.foo;
							yes.evaluate();
							verify(x3).foo.is(42);
//							test(x3.foo == 42, "Value is correct when getter redefined.");

							var x4 = new function() {
								var foo = 21;

								this.__defineGetter__("foo", function() {
									return foo;
								} );

								this.__defineSetter__("foo", function(value) {
									return (foo = value);
								} );

								deprecate(this, "foo");
							}

							var yes = expectWarn(true);
							var z = x4.foo;
							yes.evaluate();
							verify(z).is(21);
							verify(x4).foo.is(21);
//							test(z == 21);
//							test(x4.foo == 21);

							var yes = expectWarn(true);
							x4.foo = 14;
							yes.evaluate();
							verify(x4).foo.is(14);
//							test(x4.foo == 14);
						}

						var x5 = new function() {
							this.doIt = function() {
							}

							this.doItBetter = function() {
							}

							deprecate(this, "doIt");
						}

						var yes = expectWarn(true);
						x5.doIt();
						yes.evaluate();

						var yes = expectWarn(false);
						x5.doItBetter();
						yes.evaluate();
					]]></script>
				</li>
				<li class="function">
					<div class="name">experimental</div>
					<span>
						A function that can be used to mark a named property on an object as an experimental API. Its interface is
						exactly like that of <a href="#$api.deprecate"><code>deprecate</code></a>, including the presence of a
						<code>warning</code> callback that can receive information when an experimental API is used.
					</span>
				</li>
				<li class="object">
					<div class="name">warning</div>
					<span>__DESCRIPTION__</span>
					<div class="label">has properties:</div>
					<ul>
						<li class="function">
							<div class="name">once</div>
							<span>__DESCRIPTION__</span>
							<div class="arguments">
								<div class="label">Arguments</div>
								<ol>
								</ol>
							</div>
							<div class="returns">
								<div class="label">Returns</div>
								<span class="type">__TYPE__</span>
								<span>__DESCRIPTION__</span>
							</div>
						</li>
					</ul>
				</li>
				<li class="object">
					<div class="name">Function</div>
					<span>__DESCRIPTION__</span>
					<div class="label">has properties:</div>
					<ul>
						<li class="object">
							<div class="name">argument</div>
							<span>__DESCRIPTION__</span>
							<div class="label">has properties:</div>
							<ul>
								<li class="function">
									<div class="name">check</div>
									<span>Creates an argument-checking function that validates a single function argument.</span>
									<div class="arguments">
										<div class="label">Arguments</div>
										<ol>
											<li class="object">
												<span>__DESCRIPTION__</span>
												<div class="label">has properties:</div>
												<ul>
													<li class="value">
														<div class="name">index</div>
														<span class="type">number</span>
														<span>
															The index of the argument to check.
														</span>
													</li>
													<li class="value">
														<div class="name">name</div>
														<span class="type">string</span>
														<span>
															The name of the argument.
														</span>
													</li>
													<li class="value">
														<div class="name">type</div>
														<span class="type">string</span>
														<span>
															The expected type of the argument, as returned by the JavaScript
															<code>typeof</code> operator. If the argument should be a string,
															for example, the value <code>"string"</code> should be used.
														</span>
													</li>
													<li class="value">
														<div class="name">null</div>
														<span class="type">boolean</span>
														<span>
															Whether the value <code>null</code> is also an acceptable value for
															the argument.
														</span>
													</li>
													<li class="value">
														<div class="name">undefined</div>
														<span class="type">boolean</span>
														<span>
															Whether the value <code>undefined</code> is also an acceptable value for
															the argument.
														</span>
													</li>
												</ul>
											</li>
										</ol>
									</div>
									<div class="returns">
										<div class="label">Returns</div>
										<span class="type">function</span>
										<span>
											A function that takes an <code>arguments</code> object and throws a
											<code>TypeError</code> if the specified argument does not meet the specified criteria.
										</span>
									</div>
									<script type="application/x.jsapi#tests">
										var check = api.Function.argument.check;

										var tester = {
											invoke: function(argument,array) {
												var f = check(argument);
												return f.apply(this,array);
											}
										};

										verify(tester).evaluate(function() { return this.invoke({ index: 0, type: "string" },[1]) }).threw.type(TypeError);
										verify(tester).evaluate(function() { return this.invoke({ index: 0, type: "string" },[void(0)]) }).threw.type(TypeError);
										verify(tester).evaluate(function() { return this.invoke({ index: 0, type: "string" },[null]) }).threw.type(TypeError);
									</script>
								</li>
							</ul>
						</li>
					</ul>
				</li>
				<li class="object" jsapi:id="Constructor">
					(undocumented function with test coverage)
					<!--
					<div class="name">__NAME__</div>
					<span>__DESCRIPTION__</span>
					<div class="label">has properties:</div>
					<ul>
					</ul>
					-->
					<script type="application/x.jsapi#tests">
						verify(api.Constructor).is.not.equalTo(void(0));
						var A = function() {
							this.a = 1;
						};
						var B = function() {
							this.b = 2;
						};
						var C = function() {
							this.c = 3;
						};

						var AB = api.Constructor.decorated(A,B);
						var ABC = api.Constructor.decorated(AB,C);

						var abc = new ABC();
						verify(abc.a).is(1);
						verify(abc.b).is(2);
						verify(abc.c).is(3);

						var BC = api.Constructor.decorated(B,C);
						var ABC2 = api.Constructor.decorated(A,BC);
						var abc2 = new ABC2();
						verify(abc2.a).is(1);
						verify(abc2.b).is(2);
						verify(abc2.c).is(3);
					</script>
					<script type="application/x.jsapi#tests">
						verify(api).evaluate.property("Constructor").is.not(void(0));
						verify(api).Constructor.evaluate.property("invoke").is.not(void(0));

						var A = function(a,b) {
							this.a = a;
							this.b = b;
						};

						var a1 = api.Constructor.invoke({
							constructor: A,
							arguments: [1,2]
						});
						verify(a1).a.is(1);
						verify(a1).b.is(2);

						var a2 = api.Constructor.invoke({
							constructor: A,
							arguments: [1]
						});
						verify(a2).a.is(1);
						verify(a2).b.is(void(0));

						var a3 = api.Constructor.invoke({
							constructor: A,
							arguments: []
						});
						verify(a3).a.is(void(0));
						verify(a3).b.is(void(0));

						(function omittedArguments() {
							var a = api.Constructor.invoke({
								constructor: A
							});
							verify(a).a.is(void(0));
							verify(a).b.is(void(0));
						})();

						api.Constructor.global();
						(function() {
							var a = A.construct(1,2);
							verify(a).a.is(1);
							verify(a).b.is(2);
						})();
					</script>
				</li>
				<li class="function">
					<div class="name">Key</div>
					<span>__DESCRIPTION__</span>
					<div class="arguments">
						<div class="label">Arguments</div>
						<ol>
						</ol>
					</div>
					<div class="returns">
						<div class="label">Returns</div>
						<span class="type">__TYPE__</span>
						<span>__DESCRIPTION__</span>
					</div>
					<div class="label">has properties:</div>
					<ul>
						<li class="function">
							<div class="name">by</div>
							<span>__DESCRIPTION__</span>
							<div class="arguments">
								<div class="label">Arguments</div>
								<ol>
								</ol>
							</div>
							<div class="returns">
								<div class="label">Returns</div>
								<span class="type">__TYPE__</span>
								<span>__DESCRIPTION__</span>
							</div>
							<script type="application/x.jsapi#tests">
								var array = [
									{ a: 1, b: 2 },
									{ a: 1, b: 3 },
									{ a: 2, b: 4 },
									{ a: 1, b: 5 }
								];

								var lists = api.Key.by({
									key: function(value) {
										return value.a;
									},
									array: array
								});
								verify(lists)[1].length.is(3);
								verify(lists)[2].length.is(1);

								var counts = api.Key.by({
									key: function(value) {
										return value.a;
									},
									count: true,
									array: array
								});
								verify(counts)[1].is(3);
								verify(counts)[2].is(1);
								verify(counts).evaluate.property(3).is(void(0));

								var countKeys = api.Key.by({
									keys: [1,2,3],
									key: function(value) {
										return value.a;
									},
									count: true,
									array: array
								});
								verify(countKeys)[1].is(3);
								verify(countKeys)[2].is(1);
								verify(countKeys)[3].is(0);
							</script>
						</li>
					</ul>
				</li>
				<li class="object">
					<div class="name">Iterable</div>
					<span>__DESCRIPTION__</span>
					<div class="label">has properties:</div>
					<ul>
						<li class="function">
							<div class="name">groupBy</div>
							<span>__DESCRIPTION__</span>
							<div class="arguments">
								<div class="label">Arguments</div>
								<ol>
									<li class="object">
										<div class="name">__NAME__</div>
										<span>__DESCRIPTION__</span>
										<div class="label">has properties:</div>
										<ul>
											<li class="function">
												<div class="name">group</div>
												<span>__DESCRIPTION__</span>
												<div class="arguments">
													<div class="label">Arguments</div>
													<ol>
													</ol>
												</div>
												<div class="returns">
													<div class="label">Returns</div>
													<span class="type">__TYPE__</span>
													<span>__DESCRIPTION__</span>
												</div>
											</li>
											<li class="value">
												<div class="name">groups</div>
												<span class="type">__TYPE__</span>
												<span>__DESCRIPTION__</span>
											</li>
											<li class="object">
												<div class="name">codec</div>
												<span>__DESCRIPTION__</span>
												<div class="label">has properties:</div>
												<ul>
												</ul>
											</li>
											<li class="value">
												<div class="name">array</div>
												<span class="type">__TYPE__</span>
												<span>__DESCRIPTION__</span>
											</li>
											<li class="value">
												<div class="name">count</div>
												<span class="type">__TYPE__</span>
												<span>__DESCRIPTION__</span>
											</li>
										</ul>
									</li>
								</ol>
							</div>
							<div class="returns">
								<div class="label">Returns</div>
								<span>__DESCRIPTION__</span>
								<div class="label">has properties:</div>
								<ul>
								</ul>
							</div>
						</li>
					</ul>
				</li>
				<li class="function">
					<div class="name">Object</div>
					<span>__DESCRIPTION__</span>
					<div class="type">
						<a class="type" name="types.property">property</a>
						<span>__DESCRIPTION__</span>
						<div class="label">has properties:</div>
						<ul>
							<li class="value">
								<div class="name">name</div>
								<span class="type">string</span>
								<span>__DESCRIPTION__</span>
							</li>
							<li class="value">
								<div class="name">value</div>
								<span class="type">(any)</span>
								<span>__DESCRIPTION__</span>
							</li>
						</ul>
					</div>

					<div class="arguments">
						<div class="label">Arguments</div>
						<ol>
							<li class="object">
								<span>__DESCRIPTION__</span>
								<div class="label">has properties:</div>
								<ul>
									<li class="value">
										<div class="name">properties</div>
										<span class="type">Array of <a href="#types.property">property</a></span>
										<span>__DESCRIPTION__</span>
									</li>
								</ul>
							</li>
						</ol>
					</div>
					<div class="returns">
						<div class="label">Returns</div>
						<span class="type">__TYPE__</span>
						<span>__DESCRIPTION__</span>
					</div>
					<script type="application/x.jsapi#tests">
						var properties = [{ name: "foo", value: "bar" }, { name: "a", value: "b" }];
						var object = api.Object({ properties: properties });
						verify(object).foo.is("bar");
						verify(object).a.is("b");
					</script>
					<div class="label">has properties:</div>
					<ul>
						<li class="function">
							<div class="name">property</div>
							<span>__DESCRIPTION__</span>
							<div class="arguments">
								<div class="label">Arguments</div>
								<ol>
								</ol>
							</div>
							<div class="returns">
								<div class="label">Returns</div>
								<span class="type">__TYPE__</span>
								<span>__DESCRIPTION__</span>
							</div>
							<script type="application/x.jsapi#tests">
								verify(api.Object).is.not.equalTo(void(0));
								verify(api.Object.property).is.not.equalTo(void(0));
								var test = {
									name: "value"
								};
								verify(api.Object.property.call(test,"name","length")).is("value".length);
							</script>
						</li>
						<li class="function">
							<div class="name">properties</div>
							<span>Returns the list of properties for an object.</span>
							<div class="arguments">
								<div class="label">Arguments</div>
								<ol>
									<li class="value">
										<span class="type">object</span>
										<span>__DESCRIPTION__</span>
									</li>
								</ol>
							</div>
							<div class="returns">
								<div class="label">Returns</div>
								<span class="type">Array of <a href="#types.property">property</a></span>
								<span>__DESCRIPTION__</span>
							</div>
						</li>
						<li class="function">
							<div class="name">compose</div>
							<span>
								Takes a list of objects and composes them into a new object. Properties are copied from each
								source object in succession, with values from later objects replacing those from earlier objects.
							</span>
							<div class="arguments">
								<div class="label">Arguments</div>
								<ol>
								</ol>
							</div>
							<div class="returns">
								<div class="label">Returns</div>
								<span class="type">__TYPE__</span>
								<span>__DESCRIPTION__</span>
							</div>
							<script type="application/x.jsapi#tests">
								(function() {
									var composed = api.Object.compose({ a: 1, b: 1 }, { a: 2 });
									verify(composed).a.is(2);
									verify(composed).b.is(1);
								})();
							</script>
						</li>
					</ul>
				</li>
				<li class="object">
					<div class="name">Value</div>
					<span>__DESCRIPTION__</span>
					<div class="label">has properties:</div>
					<ul>
						<li class="function">
							<div class="name">require</div>
							<span>__DESCRIPTION__</span>
							<div class="arguments">
								<div class="label">Arguments</div>
								<ol>
								</ol>
							</div>
							<div class="returns">
								<div class="label">Returns</div>
								<span class="type">__TYPE__</span>
								<span>__DESCRIPTION__</span>
							</div>
							<script type="application/x.jsapi#tests"><![CDATA[
								verify(api.Value).is.not.equalTo(void(0));
								var one = {
									name: "value1",
									nested: {
										value: "nested1",
										method: function() {
											return "method";
										}
									}
								};
								var value = api.Value(one,"one");
								var disableBreakOnExceptions = ($jsapi.debug && $jsapi.debug.disableBreakOnExceptions) ? $jsapi.debug.disableBreakOnExceptions : function(f) { return f; };
								disableBreakOnExceptions(function() {
									verify(value).evaluate(function() { return this.require(); }).threw.nothing();
									verify(value).property("foo").evaluate(function() { return this.require() }).threw.type(TypeError);
									verify(value).property("foo").evaluate(function() { return this.require(); }).threw.message.is("one.foo is required");
									if (!$jsapi.java || !$jsapi.java.loader.test.HAS_NASHORN_ERROR_HACK) {
										verify(value).evaluate(function() { return this.property("foo","bar"); }).threw.type(TypeError);
									}
									verify(value).property("name").evaluate(function() { return this.require() }).threw.nothing();
									verify(value).property("name","length").evaluate(function() { return this.require() }).threw.nothing();
									verify(value).property("nested","value").evaluate(function() { return this.require() }).threw.nothing();
									verify(value).property("nested","value1").evaluate(function() { return this.require() }).threw.type(TypeError);
									verify(one).nested.method().is("method");
								})();
							]]></script>
						</li>
					</ul>
				</li>
				<li jsapi:id="Events" class="function">
					<div class="name">Events</div>
					<span>Creates an event emitter that can be used to fire events to a set of listeners. Event emitters can be arranged in a hierarchy.</span>
					<div class="type">
						<a class="type" name="types.Event">Event</a>
						<span>An event fired by an event source.</span>
						<div class="label">has properties:</div>
						<ul>
							<li class="value">
								<div class="name">type</div>
								<span class="type">string</span>
								<span>An event <dfn>type</dfn>. Event sources may define arbitrary types.</span>
								<script type="application/x.jsapi#tests">
									var emitter = api.Events();

									var event;

									emitter.listeners.add("aType", function(e) {
										event = e;
									});

									emitter.fire("aType");

									verify(event).type.is("aType");
								</script>
							</li>
							<li class="value">
								<div class="name">source</div>
								<span class="type">object</span>
								<span>
									An event <dfn>source</dfn>. This object may be the <code>Events</code> itself, or an arbitrary object specified as the logical
									event source.
								</span>
								<script type="application/x.jsapi#tests">
									var emitter = api.Events();

									var event;

									emitter.listeners.add("aType", function(e) {
										event = e;
									});

									emitter.fire("aType");

									verify(event).source.is(emitter);
								</script>
								<script type="application/x.jsapi#tests">
									var parent = api.Events();
									var child = api.Events({ parent: parent });

									var last;

									parent.listeners.add("aType", function(e) {
										last = e;
									});

									parent.fire("aType");
									verify(last).source.is(parent);
									child.fire("aType");
									verify(last).source.is(child);
								</script>
							</li>
							<li class="value">
								<div class="name">path</div>
								<span class="type">Array of emitter</span>
								<span>
									When accessed in an event handler, will be set to the current <dfn>path</dfn> in the emitter hierarchy from which
									this event was fired.
								</span>
								<script type="application/x.jsapi#tests">
									var parent = api.Events();
									var child = api.Events({ parent: parent });

									var received = {
									};

									var receive = function(name) {
										return function(e) {
											received[name] = { source: e.source, path: e.path.slice() };
										};
									};

									parent.listeners.add("aType", receive("parent"));
									child.listeners.add("aType", receive("child"));

									child.fire("aType");
			
									verify(received).parent.path.length.is(1);
									verify(received).parent.path[0].is(child);					
									verify(received).child.path.length.is(0);
								</script>
							</li>
							<li class="value">
								<div class="name">timestamp</div>
								<span class="type">number</span>
								<span>
									The time at which the event was fired, in the same format as used by the <code>Date</code> constructor.
								</span>
								<script type="application/x.jsapi#tests">
									//	TODO	mock Date to allow testing value below?

									var emitter = api.Events();

									var event;

									emitter.listeners.add("aType", function(e) {
										event = e;
									});

									emitter.fire("aType");

									verify(event).timestamp.is.type("number");
								</script>
							</li>
							<li class="value">
								<div class="name">detail</div>
								<span class="type">(any)</span>
								<span>An arbitrary value attached to the event when it is fired containing additional information.</span>
								<script type="application/x.jsapi#tests">
									var emitter = api.Events();

									var events = [];;

									emitter.listeners.add("aType", function(e) {
										events.push(e);
									});

									emitter.fire("aType");
									emitter.fire("aType", void(0));
									emitter.fire("aType", null);
									emitter.fire("aType", true);
									emitter.fire("aType", 2);
									emitter.fire("aType", "aString");
									emitter.fire("aType", { property: "value" });

									verify(events)[0].detail.is(void(0));
									verify(events)[1].detail.is(void(0));
									verify(events)[2].detail.is(null);
									verify(events)[3].detail.is(true);
									verify(events)[4].detail.is(2);
									verify(events)[5].detail.is("aString");
									verify(events)[6].detail.property.is("value");
								</script>
							</li>
						</ul>
					</div>
					<div class="type">
						<a class="type" name="types.emitter">emitter</a>
						<span>__DESCRIPTION__</span>
						<div class="label">has properties:</div>
						<ul>
							<li class="object">
								<div class="name">listeners</div>
								<span>__DESCRIPTION__</span>
								<div class="label">has properties:</div>
								<ul>
									<li class="function">
										<div class="name">add</div>
										<span>Adds an event listener that will be notified about a particular <dfn>type</dfn> of events.</span>
										<div class="arguments">
											<div class="label">Arguments</div>
											<ol>
												<li class="value">
													<span class="type">string</span>
													<span>An event <dfn>type</dfn>.</span>
												</li>
												<li class="function">
													<span>
														A listener function that will be invoked when the event occurs, with <code>this</code> set to the emitter's event source.
													</span>
													<div class="arguments">
														<div class="label">Arguments</div>
														<ol>
															<li class="value">
																<span class="type">Event</span>
																<span>An event of the specified type.</span>
															</li>
														</ol>
													</div>
												</li>
											</ol>
										</div>
										<script type="application/x.jsapi#tests">
											var emitter = api.Events();
	
											var called = false;
	
											emitter.listeners.add("aType", function() {
												verify(this).is(emitter);
												called = true;
											});
	
											emitter.fire("aType");
											verify(called).is(true);
										</script>
										<script type="application/x.jsapi#tests">
											var source = {};
											var emitter = api.Events({ source: source });
	
											var called = false;
	
											emitter.listeners.add("aType", function() {
												verify(this).is(source);
												called = true;
											});
	
											emitter.fire("aType");
											verify(called).is(true);
										</script>
										<script type="application/x.jsapi#tests">
											var parent = {};
											var child = {};
											var emitters = {};
											emitters.parent = api.Events({ source: parent });
											emitters.child = api.Events({ source: child, parent: emitters.parent });
	
											var called = {
												parent: false,
												child: false
											};
	
											emitters.parent.listeners.add("aType", function(e) {
												verify(this).is(parent);
												verify(e).source.is(child);
												called.parent = true;
											});
	
											emitters.child.listeners.add("aType", function(e) {
												verify(this).is(child);
												verify(e).source.is(child);
												called.child = true;
											});
	
											emitters.child.fire("aType");
											verify(called).parent.is(true);
											verify(called).child.is(true);
										</script>
									</li>
									<li class="function">
										<div class="name">remove</div>
										<span>Removes an event listener.</span>
										<div class="arguments">
											<div class="label">Arguments</div>
											<ol>
												<li class="value">
													<span class="type">string</span>
													<span>An event <dfn>type</dfn>.</span>
												</li>
												<li class="value">
													<span class="type">function</span>
													<span>A listener function.</span>
												</li>
											</ol>
										</div>
									</li>
									<script type="application/x.jsapi#tests">
										var source = new function() {
											var events = api.Events({ source: this });
				
											this.doIt = function(p) {
												events.fire("done", p);
											};
										};
				
										var received = [];
										var counter = function(e) {
											received.push(e);
										};
				
										verify(received).length.is(0);
										source.doIt();
										verify(received).length.is(0);
										source.listeners.add("other", counter);
										verify(received).length.is(0);
										source.doIt();
										verify(received).length.is(0);
										source.listeners.add("done", counter);
										source.doIt();
										verify(received).length.is(1);
										verify(received)[0].source.is(source);
										source.listeners.remove("done", counter);
										source.doIt();
										verify(received).length.is(1);
									</script>
								</ul>
							</li>
							<li class="function">
								<div class="name">fire</div>
								<span>Causes this object to fire an event to its listeners.</span>
								<div class="arguments">
									<div class="label">Arguments</div>
									<ol>
										<li class="value">
											<span class="type">string</span>
											<span>An event type.</span>
										</li>
										<li class="value">
											<span class="type">(any)</span>
											<span>
												An event <dfn>detail</dfn>, which can be any type, and will be used as the
												<code>detail</code> property of the created event.
											</span>
										</li>
									</ol>
								</div>
							</li>
						</ul>
					</div>

					<div class="arguments">
						<div class="label">Arguments</div>
						<ol>
							<li class="object">
								<span>__DESCRIPTION__</span>
								<div class="label">has properties:</div>
								<ul>
									<li class="value">
										<div class="name">source</div>
										<span class="type">__TYPE__</span>
										<span>__DESCRIPTION__</span>
									</li>
									<li class="value">
										<div class="name">parent</div>
										<span class="type">__TYPE__</span>
										<span>__DESCRIPTION__</span>
										<script type="application/x.jsapi#tests">
											var parent = api.Events();
											var child = api.Events({ parent: parent });

											var received = {
												parent: [],
												child: []
											};

											var receive = function(name) {
												return function(e) {
													received[name].push({ source: e.source, path: e.path.slice() });
												};
											};

											parent.listeners.add("aType", receive("parent"));
											child.listeners.add("aType", receive("child"));

											parent.fire("aType");
											verify(received).parent.length.is(1);
											verify(received).child.length.is(0);
					
											child.fire("aType");
											verify(received).parent.length.is(2);
											verify(received).child.length.is(1);
										</script>
									</li>
								</ul>
							</li>
						</ol>
					</div>

					<div class="returns">
						<div class="label">Returns</div>
						<span class="type">__TYPE__</span>
						<span>__DESCRIPTION__</span>
					</div>
					<div class="label">has properties:</div>
					<ul>
						<li class="function">
							<div class="name">Function</div>
							<span>__DESCRIPTION__</span>
							<div class="arguments">
								<div class="label">Arguments</div>
								<ol>
								</ol>
							</div>
							<div class="returns">
								<div class="label">Returns</div>
								<span class="type">__TYPE__</span>
								<span>__DESCRIPTION__</span>
							</div>
							<script type="application/x.jsapi#tests">
								var firesArgumentPropertyValues = function(p,events) {
									for (var x in p) {
										events.fire(x, p[x]);
									}
								};

								var Captor = function() {
									var events = [];

									var received = function(e) {
										events.push(e);
									};

									this.a = received;
									this.b = received;

									this.got = events;
								};

								var onPropertyValues = api.Events.Function(firesArgumentPropertyValues);
								var on = new Captor();
								onPropertyValues({}, on);
								verify(on,"on").got.length.is(0);

								var onA = new Captor();
								onPropertyValues({ a: {} }, onA);
								verify(onA,"on").got.length.is(1);
								verify(onA,"on").got[0].type.is("a");
							</script>
						</li>
					</ul>
				</li>
				<li class="object">
					<div class="name">steps</div>
					<span>__DESCRIPTION__</span>
					<div class="label">has properties:</div>
					<ul>
					</ul>
					<script type="application/x.jsapi#tests">
						verify(api,"$api").loadedByJsapi.is(true);
						verify(api,"$api").threads.steps.is.not.equalTo(null);
						verify(api,"$api").threads.steps.evaluate.property("run").is.not.equalTo(null);

						var $steps = verify(api,"$api").threads.steps;
						var $run = $steps.evaluate(function() { return this.run({ steps: [] }) });
						$run.threw.nothing();

						var A = function(shared) {
							this.ready = function() {
								return true;
							}

							this.run = function() {
								shared.a = true;
							}
						};

						var B = function(shared) {
							this.ready = function() {
								return shared.a;
							};

							this.run = function() {
								shared.b = true;
							}
						}

						var Shared = function() {
							this.a = false;
							this.b = false;
						};

						var Listener = function() {
							var unready = [];

							this.on = {
								unready: function(e) {
									unready.push(e.detail);
								}
							}

							this.unready = unready;
						}

						var s1 = new Shared();
						$steps.run({
							steps: [ new A(s1) ]
						});
						verify(s1).a.is(true);

						var s2 = new Shared();
						$steps.run({
							steps: [ new B(s2), new A(s2) ]
						});
						verify(s2).a.is(true);
						verify(s2).b.is(true);

						var s3 = new Shared();
						var b3 = new B(s3);
						var l3 = new Listener();
						$steps.run({
							steps: [ b3 ],
							on: l3.on
						});
						verify(s3).a.is(false);
						verify(s3).b.is(false);
						verify(l3).unready.length.is(1);
						verify(l3).unready[0].is(b3);
					</script>
				</li>
			</ul>
		</div>
	</body>
</html>