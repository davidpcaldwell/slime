<!--
LICENSE
This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not
distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.

The Original Code is the SLIME loader infrastructure.

The Initial Developer of the Original Code is David P. Caldwell <david@davidpcaldwell.com>.
Portions created by the Initial Developer are Copyright (C) 2010-2013 the Initial Developer. All Rights Reserved.

Contributor(s):
END LICENSE
-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:jsapi="http://www.inonit.com/jsapi">
<head>
	<title>SLIME Runtime</title>
	<link rel="stylesheet" type="text/css" href="api/api.css" />
	<script type="text/javascript" src="../loader/api/api.js"></script>
	<style>
	</style>
</head>
<body>
	<h1>Overview</h1>
	<div>
		<div jsapi:id="1">
			Generally speaking, the SLIME runtime is responsible for providing basic constructs to SLIME embeddings.
		</div>
		<div jsapi:id="2">
			The SLIME runtime provides the <a href="$api.api.html"><code>$api</code></a> and <code>$platform</code> objects.
			The <code>$api</code> provides a basic set of JavaScript utilities. The <code>$platform</code> object provides more
			advanced JavaScript engine capabilities that depend on the underlying JavaScript engine. All code loaded by the SLIME
			runtime has access to the <code>$api</code> and <code>$platform</code> objects.
		</div>
	</div>
	<div>
		<h1>Embedding</h1>
		<p>
			The SLIME runtime (<code>expression.js</code>) is an expression that evaluates to an object providing its capabilities to
			the embedder. The embedder must provide a <code>$slime</code> object that provides access to the installation, and can
			add an <code>$engine</code> object in the loader's scope in order to provide engine-specific capabilities to the
			runtime.
		</p>
		<div>
			<h2><code>$slime</code></h2>
			<span>An object providing access to the SLIME execution environment.</span>
			<div class="label">has properties:</div>
			<ul>
				<li class="experimental function">
					<div class="name">getCode</div>
					<span>
						Returns a component source file of the loader.
					</span>
					<div class="arguments">
						<div class="label">Arguments</div>
						<ol>
							<li class="value">
								<span class="type">string</span>
								<span>The path to a SLIME source file, relative to the loader.</span>
							</li>
						</ol>
					</div>
					<div class="returns">
						<div class="label">Returns</div>
						<span class="type">string</span>
						<strong>This interface may change to return an instance of the <i>script</i> type.</strong>
						<span>The code contained in the source file.</span>
					</div>
				</li>
				<li class="function">
					<div class="name">getCoffeeScript</div>
					<span>Returns an implementation of CoffeeScript, if one is present.</span>
					<div class="returns">
						<div class="label">Returns</div>
						<span class="type">object</span>
						<span>
							An object containing the CoffeeScript implementation, or <code>null</code> if CoffeeScript is not
							present.
						</span>
						<div class="label">has properties:</div>
						<ul>
							<li class="value">
								<div class="name">object</div>
								<span class="type">object</span>
								<span>(optional) The CoffeeScript object.</span>
							</li>
							<li class="value">
								<div class="name">code</div>
								<span class="type">string</span>
								<span>
									(optional) The JavaScript code for the CoffeeScript object, which can be executed to
									produce the CoffeeScript object.
								</span>
							</li>
						</ul>
					</div>
				</li>
			</ul>
		</div>
		<div>
			<h2><code>$engine</code></h2>
			<p>
				The <code>$engine</code> object can be provided in the scope by the embedding in order to provide additional
				capabilities the JavaScript engine may have.
			</p>
			<ul>
				<li class="object">
					<div class="name">Object</div>
					<span></span>
					<div class="label">has properties:</div>
					<ul>
						<li class="object">
							<div class="name">defineProperty</div>
							<span></span>
							<div class="label">has properties:</div>
							<ul>
								<li class="function">
									<div class="name">setReadOnly</div>
									<span>
										An object that implements the behavior defined by
										<a href="#$platform.Object.defineProperty.setReadOnly"><code>$platform.Object.defineProperty.setReadOnly</code></a>.
									</span>
								</li>
							</ul>
						</li>
					</ul>
				</li>
				<li class="constructor">
					<div class="name">MetaObject</div>
					<span>
						A function that implements the behavior defined by
						<a href="#$platform.MetaObject"><code>$platform.MetaObject</code></a>.
					</span>
				</li>
				<li class="function">
					<div class="name">execute</div>
					<span>A function that can execute JavaScript code with a given scope and <i>target</i> (<code>this</code> value).</span>
					<div class="arguments">
						<div class="label">Arguments</div>
						<ol>
							<li class="object">
								<span>An object describing the file to execute.</span>
								<div class="label">has properties:</div>
								<ul>
									<li class="value">
										<div class="name">code</div>
										<span class="type">string</span>
										<span>A string of JavaScript code to execute.</span>
									</li>
								</ul>
							</li>
							<li class="value">
								<span class="type">object</span>
								<span>
									A scope to provide to the object; all the properties of this object must be in scope while
									the code executes.
								</span>
							</li>
							<li class="value">
								<span class="type">object</span>
								<span>
									An object to provide to the code as <code>this</code> while the code is executing.
								</span>
							</li>
						</ol>
					</div>
				</li>
			</ul>
		</div>
		<div>
			<h2>Properties</h2>
			<p>
				The platform loader is normally loaded within an environment-specific embedding, so the following exports are not
				normally available to application code: they are available to the environment-specific embedding to expose to
				application code as needed.
			</p>
			<p>
				Note that although there are global <code>run()</code>, <code>file()</code>, and <code>value()</code> methods that
				can be used to execute code, there is no global <code>module()</code> method. Since modules themselves load code, in
				order to create a module, code loading capability is needed. For this reason, the loader API exposes the ability to 
				load modules via first creating a
				<a href="#types.Loader">Loader</a> implementation and then using the <code>module()</code> method of the
				<code>Loader</code>.
			</p>
			<script type="application/x.jsapi#initialize">
				scope.api = $jsapi.loader.eval("expression.js", {
					$slime: {
						getLoaderScript: function(path) {
							return {
								name: path,
								code: $jsapi.loader.string(path)
							}
						},
						getCoffeeScript: function() {
							return null;
						}
					},
					$engine: void(0)
				});
				scope.loadTestModule = function(path,context) {
					return $jsapi.loader.module(path,context);
				}
			</script>
			<div class="label">has properties:</div>
			<ul>
				<li class="value">
					<div class="name">mime</div>
					<span class="type"><a href="mime.api.html">SLIME MIME API</a></span>
					<span>Provides APIs relating to MIME types.</span>
				</li>
				<li class="constructor">
					<div class="name">Resource</div>
					<span>
						Creates a <code>Resource</code>.
					</span>
					<div class="type">
						<a class="type" name="types.Resource.source">source</a>
						<span>Provides the implementation for a <a href="#types.Resource">Resource</a>.</span>
						<div class="label">has properties:</div>
						<ul>
							<li class="value">
								<div class="name">type</div>
								<span class="type">string</span>
								- OR -
								<span class="type"><a href="#types.mime.Type">mime.Type</a></span>
								<span>
									(optional)
									The MIME type of the resource.
								</span>
							</li>
							<li class="value">
								<!--
										TODO	should we provide default implementation of this property that sets it to the basename
												as determined by path? Or to the full path?
								-->
								<div class="name">name</div>
								<span class="type">string</span>
								<span>
									(optional)
									The name of the resource. May be used (by file extension, for example) to determine the type of the
									file.
								</span>
							</li>
							<li class="value">
								<div class="name">string</div>
								<span class="type">string</span>
								<span>
									(optional)
									The content of the resource as a string.
								</span>
							</li>
							<li class="object">
								<div class="name">read</div>
								<span>__DESCRIPTION__</span>
								<div class="label">has properties:</div>
								<ul>
									<li class="function">
										<div class="name">string</div>
										<span>
											(optional)
											Returns the content of the resource as a string.
										</span>
										<div class="returns">
											<div class="label">Returns</div>
											<span class="type">string</span>
										</div>
									</li>
								</ul>
							</li>
						</ul>
					</div>
					<div class="arguments">
						<div class="label">Arguments</div>
						<ol>
							<li class="value">
								<span class="type"><a href="#types.Resource.source">source</a></span>
								<span>__DESCRIPTION__</span>
							</li>
						</ol>
					</div>
					<div class="instances">
						<div class="label">Instances</div>
						<span>Instances conform to the following type:</span>
						<div class="label">has properties:</div>
						<ul>
							<li class="value">
								<div class="name">type</div>
								<span class="type"><a href="mime.api.html#types.type">mime.Type</a></span>
								<span>
									The type of the resource, or <code>null</code> if the type cannot be determined. If no type 
									was specified, and a name was specified, the implementation
									will attempt to deduce the type from the name.
								</span>
								<script type="application/x.jsapi#tests">
									(function() {
										var resource = new api.Resource({});
										verify(resource).type.is(null);
									})();
									(function() {
										var resource = new api.Resource({
											type: api.mime.Type.parse("application/json")
										});
										verify(resource).type.toString().is("application/json");
									})();
									(function() {
										var resource = new api.Resource({
											name: "foo.js"
										});
										verify(resource).type.toString().is("application/javascript");
									})();
									(function() {
										var resource = new api.Resource({
											name: "foo.x"
										});
										verify(resource).type.is(null);
									})();
								</script>
							</li>
							<li class="value">
								<div class="name">name</div>
								<span class="type">string</span>
								<span>
									(conditional)
									The name of the resource, if available.
								</span>
								<script type="application/x.jsapi#tests">
									(function() {
										var resource = new api.Resource({
											name: "foo"
										});
										verify(resource).name.is("foo");
									})();
									(function() {
										var resource = new api.Resource({});
										verify(resource).evaluate.property("name").is(void(0));
									})();
								</script>
							</li>
							<li class="function">
								<div class="name">read</div>
								<span>Provides the content of this resource in a format specified by its argument.</span>
								<div class="arguments">
									<div class="label">Arguments</div>
									<ol>
										<li class="value">
											<span class="type">The String function, the JSON function <span class="deprecated">, or the XML function</span>.</span>
											<span>A constant value indicating the type desired.</span>
										</li>
									</ol>
								</div>
								<div class="returns">
									<div class="label">Returns</div>
									<span class="type">String</span>,
									<span class="type">object</span>,
									<span class="deprecated">or <span class="type">XML</span></span>
									<span>Depending on the type argument given, returns the content of the resource in the given format.</span>
								</div>
								<script type="application/x.jsapi#tests"><![CDATA[
									(function() {
										var resource = new api.Resource({
											string: "foo" 
										});
										verify(resource).read(String).is("foo");
									})();
									
									(function() {
										var resource = new api.Resource({
											read: {
												string: function() {
													return "bar";
												}
											}
										});
										verify(resource).read(String).is("bar");
									})();
									
									(function() {
										var resource = new api.Resource({
											string: JSON.stringify({ foo: "bar" })
										});
										var json = resource.read(JSON);
										verify(json).foo.is("bar");
										verify(json).evaluate.property("baz").is(void(0));
									})();
									
									if ($platform.e4x) {
										var resource = new api.Resource({
											string: "<a><b/></a>"
										});
										var xml = resource.read(XML);
										verify(xml).is.type("xml");
										
										var list = { list: resource.read(XMLList) };
										verify(list).list.is.type("xml");
										verify(list).evaluate(function(v) { return v.list.length(); }).is(1);
									}
								]]></script>
							</li>
						</ul>
					</div>
				</li>
				<div class="type">
					<a class="type" name="types.script">script</a>
					<span>
						A <code>Resource.source</code> or <code>Resource</code>. If it is a <code>Resource.source</code>, it 
						<em>must</em> have either a <code>string</code> property or a <code>read.string()</code> function.
						If no MIME type can be determined, the type will be assumed to be <code>application/javascript</code>.
						<code>application/javascript</code> scripts will be executed as
						JavaScript. <code>application/vnd.coffeescript</code> will be interpreted as CoffeeScript. The 
						<code>name</code> property, if provided, may be used by the underlying JavaScript engine when evaluating
						the resource as code (for display in tools, for example).							
					</span>
				</div>
				<li class="function" jsapi:id="run">
					<div class="name"><a id="exports.run">run</a></div>
					<span jsapi:id="description">
						Analogous to <a href="#Loader.run">Loader.run()</a>, except that the caller specifies a
						<a href="#types.script">script</a> to execute rather than a path within a <a href="#types.Loader">Loader</a>.
					</span>
					<div jsapi:id="arguments" class="arguments">
						<div class="label">Arguments</div>
						<ol>
							<li class="value">
								<span class="type"><a href="#types.script">script</a></span>
								<span>The script to execute.</span>
							</li>
							<li class="value" jsapi:id="arguments[1]">
								<span class="type">object</span>
								<span>See <a href="#Loader.run">Loader.run()</a>.</span>
							</li>
							<li class="value" jsapi:id="arguments[2]">
								<span class="type">object</span>
								<span>See <a href="#Loader.run">Loader.run()</a>.</span>
							</li>
						</ol>
					</div>
				</li>
				<li class="function" jsapi:id="file">
					<div class="name"><a id="exports.file">file</a></div>
					<span jsapi:id="description">
						Analogous to <a href="#Loader.file">Loader.file()</a>, except that the caller specifies a
						<a href="#types.script">script</a> to execute rather than a path within a <a href="#types.Loader">Loader</a>.
					</span>
					<div jsapi:id="arguments" class="arguments">
						<div class="label">Arguments</div>
						<ol>
							<li class="value">
								<span class="type"><a href="#types.script">script</a></span>
								<span>The script to execute.</span>
							</li>
							<li class="value" jsapi:id="arguments[1]">
								<span class="type">object</span>
								<span>See <a href="#Loader.file">Loader.file()</a>.</span>
							</li>
							<li class="value" jsapi:id="arguments[2]">
								<span class="type">object</span>
								<span>See <a href="#Loader.file">Loader.file()</a>.</span>
							</li>
						</ol>
					</div>
					<div class="returns" jsapi:id="returns">
						<div class="label">Returns</div>
						<span>See <a href="#Loader.file">Loader.file()</a>.</span>
					</div>
				</li>
				<li jsapi:id="value" class="function">
					<div class="name"><a id="exports.value">value</a></div>
					<span jsapi:id="description">
						Analogous to <a href="#types.Loader.value">Loader.value()</a>, except that the caller specifies a
						<a href="#types.script">script</a> to execute rather than a path within a <a href="#types.Loader">Loader</a>.
					</span>
					<div class="arguments">
						<div class="label">Arguments</div>
						<ol>
							<li class="value">
								<span class="type"><a href="#types.script">script</a></span>
								<span>The script to execute.</span>
							</li>
							<li class="value" jsapi:id="arguments[1]">
								<span class="type">object</span>
								<span>See <a href="#types.Loader.value">Loader.value()</a>.</span>
							</li>
							<li class="value" jsapi:id="arguments[2]">
								<span class="type">object</span>
								<span>See <a href="#types.Loader.value">Loader.value()</a>.</span>
							</li>
						</ol>
					</div>
					<div class="returns">
						<div class="label">Returns</div>
						<span>See <a href="#types.Loader.value">Loader.value()</a>.</span>
					</div>
				</li>
				<li class="constructor" jsapi:id="Loader">
					<div class="name"><a name="exports.Loader">Loader</a></div>
					<span>Creates a <a href="#types.Loader">Loader</a>. A <i>Loader</i> loads resources from a specified source.</span>
					<div class="type">
						<a class="type" name="types.Loader.source">source</a>
						<span>__DESCRIPTION__</span>
						<div class="label">has properties:</div>
						<ul>
							<li class="function">
								<div class="name">toString</div>
								<span>
									(optional)
									Provides the <code>toString</code> for the created Loader by default.
								</span>
							</li>
							<li class="function">
								<div class="name">get</div>
								<span>Retrieves a resource.</span>
								<div class="arguments">
									<div class="label">Arguments</div>
									<ol>
										<li class="value">
											<span class="type">string</span>
											<span>The path from which to load a resource.</span>
										</li>
									</ol>
								</div>
								<div class="returns">
									<div class="label">Returns</div>
									<span class="type"><a href="#types.Loader.resource">resource</a></span>
									<span>The resource at the given path, or <code>null</code> if there is none.</span>
								</div>
							</li>
							<li class="function">
								<div class="name">child</div>
								<span>
									(optional; if omitted, a child that delegates requests back to the parent, prepended by the
									child's path, will be created)
									A factory method that this loader implementation can use to create its own child implementations.
								</span>
								<div class="arguments">
									<div class="label">Arguments</div>
									<ol>
										<li class="value">
											<span class="type">string</span>
											<span>
												The path representing this child underneath the parent.
												<span class="experimental">
													Currently, this path can be either the empty string <code>""</code> or a string
													ending in <code>/</code>.
												</span>
											</span>
										</li>
									</ol>
								</div>
								<div class="returns">
									<div class="label">Returns</div>
									<span class="type"><a href="">source</a></span>
									<span>A source that represents a child of the parent source.</span>
								</div>
							</li>
							<li class="function experimental">
								<div class="name">list</div>
								<span>Returns a list of the top-level entries at a particular location in this loader.</span>
								<div class="type">
									<a class="type" name="types.Loader.list.arguments[0].entry">entry</a>
									<span>Either a resource or a child loader contained within a Loader.</span>
									<div class="label">has properties:</div>
									<ul>
										<li class="value">
											<div class="name">path</div>
											<span class="type">string</span>
											<span>
												The name of this entry. It does <em>not</em> have a trailing slash for loaders.
											</span>
										</li>
										<li class="value">
											<div class="name">loader</div>
											<span class="type">boolean</span>
											<span>
												Whether this entry represents a child loader (for example, a directory or
												folder)
											</span>
										</li>
										<li class="value">
											<div class="name">resource</div>
											<span class="type">boolean</span>
											<span>Whether this entry represents a resource.</span>
										</li>
									</ul>
								</div>
								<div class="arguments">
									<div class="label">Arguments</div>
									<ol>
										<li class="value">
											<span class="type">string</span>
											<span>A path under this loader to list.
												<span class="experimental">Currently, this will either be the empty
												string, in which case the top level should be listed, or it will be a path
												ending in <code>/</code>.</span>
											</span>
										</li>
									</ol>
								</div>
								<div class="returns">
									<div class="label">Returns</div>
									<span class="type">Array of <a href="#types.Loader.list.arguments[0].entry">entry</a></span>
								</div>
							</li>
						</ul>
					</div>
					<div class="arguments">
						<div class="label">Arguments</div>
						<ol>
							<li class="value">
								<span class="type"><a href="#types.Loader.source">source</a></span>
								<span>The implementation of this <code>Loader</code>.</span>
							</li>
						</ol>
					</div>
					<div class="instances" jsapi:id="type">
						<div class="label">Instances</div>
						<div class="label">has properties:</div>
						<ul>
							<li class="value">
								<div class="name">source</div>
								<span class="type"><a href="#types.Loader.source">source</a></span>
								<span>__DESCRIPTION__</span>
							</li>
							<li class="function">
								<div class="name">get</div>
								<span>Returns the resource associated with a given path, by invoking the <code>get</code> method of this
									loader's <code>source</code>.
								</span>
								<div class="arguments">
									<div class="label">Arguments</div>
									<ol>
										<li class="value">
											<span class="type">string</span>
											<span>A path.</span>
										</li>
									</ol>
								</div>
								<div class="returns">
									<div class="label">Returns</div>
									<span class="type"><a href="#types.Loader.resource">resource</a></span>
									<span>__DESCRIPTION__</span>
								</div>
							</li>
							<li class="function" jsapi:id="run">
								<div class="name"><a name="Loader.run">run</a></div>
								<span jsapi:id="description">
									Executes code in a particular scope with a particular <code>this</code> value. The code will automatically
									contain the <code>$platform</code> and <code>$api</code> objects described above in its scope.
								</span>
								<div class="arguments" jsapi:id="arguments">
									<div class="label">Arguments</div>
									<ol>
										<li class="value">
											<span class="type">string</span>
											<span>The path of the code to execute.</span>
										</li>
										<li class="value" jsapi:id="arguments[1]">
											<span class="type">object</span>
											<span>The scope in which to execute the code.</span>
										</li>
										<li class="value" jsapi:id="arguments[2]">
											<span class="type">object</span>
											<span>The object to use as the <code>this</code> value when executing the code.</span>
										</li>
									</ol>
								</div>
							</li>
							<li class="function" jsapi:id="file">
								<div class="name"><a name="Loader.file">file</a></div>
								<span jsapi:id="description">
									Executes a script in a separate scope. The scope will contain the <code>$platform</code> and <code>$api</code>
									objects described above. In addition, the script will be provided with special objects named
									<code>$context</code> and <code>$exports</code>. The <code>$context</code> object represents an
									application-specific context to provide to the script; the <code>$exports</code> object represents an object to
									which the script can assign properties that will be visible outside the script.
								</span>
								<div class="arguments" jsapi:id="arguments">
									<div class="label">Arguments</div>
									<ol>
										<li class="value">
											<span class="type">string</span>
											<span>The path of the code to execute.</span>
										</li>
										<li class="value" jsapi:id="arguments[1]">
											<span class="type">object</span>
											<span>
												An object to use as the <code>$context</code> object when executing the given code. If absent, an
												empty object will be supplied.
												<!--	TODO	What about if it is a number, string, or boolean?	-->
											</span>
										</li>
										<li class="value" jsapi:id="arguments[2]">
											<span class="type">object</span>
											<span>The object to use as the <code>this</code> value when executing the code.</span>
										</li>
									</ol>
								</div>
								<div class="returns" jsapi:id="returns">
									<div class="label">Returns</div>
									<span class="type">object</span>
									<span>An object which contains the properties the script assigned to the <code>$exports</code> object.</span>
								</div>
							</li>
							<li class="function" jsapi:id="module">
								<div class="name">module</div>
								<div jsapi:id="description">
									<span jsapi:id="summary">
										Loads a module. The module's code is specified by the first argument, and the second argument specifies
										objects to be supplied to the module when loading it.
									</span>
									The module's main file will be executed with the following variables in scope:
									<ul>
										<li>the <code>$platform</code> and <code>$api</code> objects specified above,</li>
										<li>the <code>$context</code> object specified by the second argument,</li>
										<li>an <code>$exports</code> object,</li>
										<li>
											a <code>$loader</code> object of type <a href="#types.Loader">Loader</a> allowing other source
											files and submodules to be loaded.
										</li>
									</ul>
								</div>
								<div class="arguments" jsapi:id="arguments">
									<div class="label">Arguments</div>
									<ol>
										<li class="value">
											<span class="type">string</span>
											<span>The path of the code to execute.</span>
										</li>
										<li class="value" jsapi:id="arguments[1]">
											<span class="type">object</span>
											<span>
												An object to use as the <code>$context</code> object when executing the given code. If absent, an
												empty object will be supplied.
												<!--	TODO	What about if it is a number, string, or boolean?	-->
											</span>
										</li>
										<li class="value" jsapi:id="arguments[2]">
											<span class="type">object</span>
											<span>The object to use as the <code>this</code> value when executing the code.</span>
										</li>
									</ol>
								</div>
								<div class="returns" jsapi:id="returns">
									<div class="label">Returns</div>
									<span class="type">object</span>
									<span>An object containing this module's exports.</span>
								</div>
							</li>
							<li class="function" jsapi:id="value">
								<div class="name"><a id="types.Loader.value">value</a></div>
								<div jsapi:id="description">
									Identical to <code>run</code>, except that the code to execute is supplied with a <code>$set</code>
									function in its scope that allows it to set a value to be returned to the caller:
									<div class="label">has properties:</div>
									<ul>
										<li class="function">
											<div class="name">$set</div>
											<span>Allows the code to return a single value to the caller.</span>
											<div class="arguments">
												<div class="label">Arguments</div>
												<ol>
													<li class="value">
														<span class="type">(any)</span>
														<span>The value to return.</span>
													</li>
												</ol>
											</div>
										</li>
									</ul>
								</div>
								<div class="arguments" jsapi:id="arguments">
									<div class="label">Arguments</div>
									See <a href="#Loader.run">run</a>.
								</div>
								<div class="returns" jsapi:id="returns">
									<div class="label">Returns</div>
									<span class="type">(any)</span>
									<span>
										The value the code to execute passed to <code>$set</code>, or <code>undefined</code> if
										<code>$set</code> was not invoked.
									</span>
								</div>
							</li>
							<li class="function">
								<div class="name">list</div>
								<span>
									(conditional; not present if <code>source.list()</code> not present)
								</span>
								<div class="type">
									<a class="type" name="types.Loader.entry">entry</a>
									<span>__DESCRIPTION__</span>
									<div class="label">has properties:</div>
									<ul>
										<li class="value">
											<div class="name">path</div>
											<span class="type">__TYPE__</span>
											<span>__DESCRIPTION__</span>
										</li>
										<li class="value">
											<div class="name">resource</div>
											<span class="type">__TYPE__</span>
											<span>
												(optional; if the item at <code>path</code> is a resource)
											</span>
										</li>
										<li class="value">
											<div class="name">loader</div>
											<span class="type">__TYPE__</span>
											<span>
												(optional; if the item at <code>path</code> is a loader)
											</span>
										</li>
									</ul>
								</div>
								<div class="arguments">
									<div class="label">Arguments</div>
									<ol>
										<li class="object">
											<div class="label">has properties:</div>
											<ul>
												<li class="function">
													<div class="name">filter</div>
													<span>__DESCRIPTION__</span>
													<div class="arguments">
														<div class="label">Arguments</div>
														<ol>
														</ol>
													</div>
													<div class="returns">
														<div class="label">Returns</div>
														<span class="type">__TYPE__</span>
														<span>__DESCRIPTION__</span>
													</div>
												</li>
												<li class="function">
													<div class="name">descendants</div>
													<span>__DESCRIPTION__</span>
													<div class="arguments">
														<div class="label">Arguments</div>
														<ol>
														</ol>
													</div>
													<div class="returns">
														<div class="label">Returns</div>
														<span class="type">__TYPE__</span>
														<span>__DESCRIPTION__</span>
													</div>
												</li>
											</ul>
										</li>
									</ol>
								</div>
								<div class="returns">
									<div class="label">Returns</div>
									<span class="type">__TYPE__</span>
									<span>__DESCRIPTION__</span>
								</div>
							</li>
							<div jsapi:id="tests">
								<script type="application/x.jsapi#tests"><![CDATA[
									var Tests = function(p) {
										var a = function(scope) {
											if (!scope.verify) throw new Error("No scope.verify; scope keys = " + Object.keys(scope));
											if (!p.loadTestModule) throw new Error("No p.loadTestModule");
											var module = scope.verify(p.loadTestModule("test/data/a/", {
												d: 1970
											}), "test/data/a");
											module.a.is(3);
											module.b.is(4);
											module.c.is(5);
											module.d.is(1970);
											module.e.is(4);
											module.f.is(6);
											module.fThis.is("fThis");
											module.mThis.is("mThis");
											module.value.is(5);
											module.vThis.thisName.is("vThis:4");
										};

										var b = function(scope) {
											var module = scope.verify(p.loadTestModule("test/data/b/", {
											}), "test/data/b");
											module.submodule.message.is("ititit");
										}

										var c = function(scope) {
											var module = scope.verify(p.loadTestModule("test/data/c/main.js", {
											}), "test/data/c/main");
											module.value.is(13);
											module.other.is(42);
										};

										var rhino = function(scope) {
											var module = scope.verify(p.loadTestModule("jrunscript/test/data/1/", {
											}), "rhino/test/data/1");
											var $java = (function() {
												if (this.jsh && this.jsh.java && this.jsh.java.getClass) return this.jsh.java.getClass("slime.Data");
												try {
													Packages.java.lang.Class.forName("slime.Data");
													return true;
												} catch (e) {
													return false;
												}
											})();
											if ($java) {
												module.data.is("From Java");
											} else {
												module.data.is("No Java");
											}
										};

										var coffee = function(scope) {
											//	TODO	for some reason these (at least sometimes) do not run in browser
											if ($jsapi.loader.coffee) {
												// TODO: Below works around issue with relative path being incorrect when this file
												// is invoked from a file which in turn is invoked from another file; happens in
												// test suite currently. Should be refactored out as we work to run tests directly
												// rather than via includes
												var PREFIX = ($jsapi.loader.getRelativePath && $jsapi.loader.getRelativePath(".").basename == "jrunscript") ? "../" : "";
												var loader = $jsapi.loader.module(PREFIX + "test/data/coffee/loader.js");
												var coffee = $jsapi.loader.module(PREFIX + "test/data/coffee/module.coffee");
												scope.verify(coffee,"coffee").a.is(2);
												scope.verify(coffee,"coffee").file.b.is(3);
												scope.verify(loader,"loader").file.b.is(3);
												var file = $jsapi.loader.file(PREFIX + "test/data/coffee/file.coffee");
												scope.verify(file,"file").b.is(3);
											} else {
												scope.verify("No CoffeeScript").is("No CoffeeScript");
											}
										}

										this.run = function(scope) {
											a(scope);
											b(scope);
											c(scope);
											rhino(scope);
											coffee(scope);
										}
									};
									new Tests(scope).run({
										test: test,
										verify: verify
									});
								]]></script>
							</div>
						</ul>
					</div>
					<div class="label">has properties:</div>
					<ul>
						<li class="object">
							<div class="name">source</div>
							<span>__DESCRIPTION__</span>
							<div class="label">has properties:</div>
							<ul>
								<li class="constructor">
									<!-- TODO: should this be a constructor or a function? Should it be capitalized? -->
									<div class="name">object</div>
									<span>Creates an loader source defined by a single JavaScript object.</span>
									<div class="arguments">
										<div class="label">Arguments</div>
										<ol>
											<li class="value">
												<span class="type">object</span>
												<span>__DESCRIPTION__</span>
											</li>
										</ol>
									</div>
									<div class="instances">
										<div class="label">Instances</div>
										<span class="type"><a href="#types.Loader.source">source</a></span>
									</div>
									<script type="application/x.jsapi#tests">
										verify(api).evaluate(function() { return this.Loader.source.object; }).is.type("function");
										var source = new api.Loader.source.object({
											a: {
												resource: {
													string: "a"
												}
											},
											b: {
												loader: {
													c: {
														resource: {
															string: "c"
														}
													}
												}
											}
										});
										var loader = new api.Loader(source);
										verify(loader).get("a").string.is("a");
										verify(loader).get("b/c").string.is("c");
										verify(loader).list().length.is(2);
									</script>
								</li>
							</ul>
						</li>
						<li class="experimental function">
							<div class="name">series</div>
							<span>
								A loader that uses a series of loaders to resolve resources. For a given path, each loader is searched
								in turn until a resource is found.
							</span>
							<div>
								The created loaders currently have the following limitations:
								<!--	TODO	address them	-->
								<ul>
									<li>They are not enumerable</li>
									<li>They do not respect the <code>.child</code> implementations of their elements</li>
									<li>They do not provide a sensible <code>.toString</code> implementation.</li>
								</ul>
							</div>
							<div class="arguments">
								<div class="label">Arguments</div>
								<ol>
									<li class="value">
										<span class="type">Array</span>
										<span>A list of <code>Loader</code>s</span>
									</li>
								</ol>
							</div>
							<div class="returns">
								<div class="label">Returns</div>
								<span class="type">Loader</span>
								<span>A loader that looks up resources in the given list of underlying loaders.</span>
							</div>
						</li>
					</ul>
					<div jsapi:id="tests">
						<script type="application/x.jsapi#initialize"><![CDATA[
							scope.Mock = function recurse() {
								var contents = {};

								this.add = function(path,value) {
									var tokens = path.split("/");
									if (tokens.length == 1) {
										if (typeof(value) == "string") {
											value = { string: value };
										}
										contents[path] = { resource: value };
									} else {
										if (!contents[tokens[0]]) {
											contents[tokens[0]] = { child: new recurse() };
										}
										contents[tokens[0]].child.add(tokens.slice(1).join("/"), value);
									}
								}

								this.loader = new api.Loader({
									get: function(path) {
										var tokens = path.split("/");
										if (tokens.length == 1) {
											return (contents[path]) ? contents[path].resource : null;
										} else {
											if (contents[tokens[0]]) {
												var loader = contents[tokens[0]].child.loader.source;
												if (!loader) {
													throw new Error("No loader at " + tokens[0] + " for " + path);
												}
												if (!loader.get) throw new Error("No loader.get in " + Object.keys(loader));
												return loader.get(tokens.slice(1).join("/"));
											}
											return null;
										}
									},
									list: function(prefix) {
										if (prefix) {
											var tokens = prefix.split("/");
											return contents[tokens[0]].child.loader.source.list(tokens.slice(1).join("/"));
										} else {
											var rv = [];
											for (var x in contents) {
												var item = { path: x, resource: Boolean(contents[x].resource), loader: Boolean(contents[x].child) };
												rv.push(item);
											}
										}
									}
								});
							}
						]]></script>
						<script type="application/x.jsapi#tests">
							var loader = new api.Loader({
								get: function(path) {
									if (path == "a") {
										return {
											string: "a"
										}
									} else if (path == "b/c") {
										return {
											string: "c"
										}
									}
								},
								list: function(prefix) {
									if (prefix == "b/") return [ { path: "c", resource: true } ];
									return [ { path: "a", resource: true }, { path: "b", loader: true } ]
								}
							});
							var listing = loader.list({ descendants: function() { return true; } } );
							verify(listing).length.is(3);
							verify(listing)[0].path.length.is(1);
							verify(listing)[0].path.is("a");
							verify(listing)[1].path.is("b");
							verify(listing)[2].path.is("b/c");
						</script>
						<script type="application/x.jsapi#tests">
							var mock1 = new Mock();
							mock1.add("a", "sa");
							var mock2 = new Mock();
							mock2.add("b/c", "sb/c");
							var series = api.Loader.series([mock1.loader,mock2.loader]);
							verify(series).get("foo").is(null);
							verify(series).get("a").string.is("sa");
							verify(series).get("b/c").string.is("sb/c");
						</script>
					</div>
				</li>
				<li class="function" jsapi:id="namespace">
					<div class="name"><a id="exports.namespace">namespace</a></div>
					<!--
					TODO	this documentation copied from older version; merge with below

					Creates a <i>namespace</i>, a scope object that has a given position in the global scope. For example, a
					namespace named "inonit.foo.bar" is the <code>bar</code> property of an object which is the <code>foo</code>
					property of another object which is in turn the <code>inonit</code> property of the global object.
					<div>
						If some or all of the named properties exist, the existing ones will be used; they will not be created. Thus, if
						the global object already has an <code>inonit</code> property, and that object has a <code>foo</code> property,
						but the <code>inonit.foo</code> object does not have a <code>bar</code> property, a single object will be
						created and assigned to the <code>bar</code> property of the existing <code>inonit.foo</code> object.
					</div>
					<div class="arguments">
						<div class="label">Arguments</div>
						<ol>
							<li><span class="type">string</span> The name of the namespace to create (or return if it exists).</li>
						</ol>
					</div>
					<div class="returns">
						<div class="label">Returns</div>
						<span class="type">object</span> A namespace located at the given name.
					</div>
					-->
					<span>
						Creates a <i>namespace</i>. A namespace is an object which is globally visible because it is rooted to the
						global object (e.g., <code>window</code> in the browser). So, in the browser, the namespace
						<code>inonit.foo.bar</code> would be an object that is the <code>bar</code> property of an object that is the
						<code>foo</code> property of an object that is the <code>inonit</code> property of <code>window</code>. It could
						be referenced as <code>inonit.foo.bar</code> in JavaScript code, or alternatively as
						<code>window.inonit.foo.bar</code> in the browser.
					</span>
					<p>
						In the event portions of the sequence of rooting objects do not exist, they will be created. So, for example, in
						the browser-based example above, if the <code>window.inonit</code> object exists, but the
						<code>window.inonit</code> object does not have a property named <code>foo</code>, an object will be created
						and assigned to the <code>foo</code> property of <code>window.inonit</code>, and then an object will be created
						and assigned to that object's <code>bar</code> property.
					</p>
					<p>
						If the full sequence of rooting objects exists, the object at the given location will be returned.
					</p>
					<div class="arguments">
						<div class="label">Arguments</div>
						<ol>
							<li class="value">
								<span class="type">string</span>
								<span>The name/location of the namespace to create.</span>
							</li>
						</ol>
					</div>
					<div class="returns">
						<div class="label">Returns</div>
						<span class="type">object</span>
						<span>
							The object at the specified location. The object (and its parents) will be created if it does not
							exist.
						</span>
					</div>
				</li>
				<li class="object">
					<div class="name">java</div>
					<span>The same object as <code>$platform.java</code>.</span>
				</li>
				<li class="object">
					<div class="name">$platform</div>
					<span>The same object as <code>$platform</code>.</span>
				</li>
				<li class="object">
					<div class="name">$api</div>
					<span>An additional way for embedding environments to access the <a href="$api.api.html">$api</a> object.</span>
					<span jsapi:id="$api">See <a href="$api.api.html">detailed documentation</a>.</span>
				</li>
			</ul>
		</div>
	</div>
	<div>
		<h1>Objects provided to loaded code</h1>
		<div>
			The following objects are automatically present in the scope by all code loaded by the SLIME loader.
		</div>
		<div>
			<h2><code>$api</code></h2>
			<p>
				Provides a set of basic JavaScript utilities. See <a href="$api.api.html">detailed documentation</a>.
			</p>
		</div>
		<div jsapi:id="$platform">
			<h2><code>$platform</code></h2>
			<div>
				When code is loaded by the loader, the loader provides the <code>$platform</code> object to that code in the scope.
				The <code>$platform</code> object provides information about
				the underlying JavaScript platform; the loaded code can use this information in its implementation.
			</div>
			<ul>
				<li class="object">
					<div class="name">Object</div>
					<span>An object containing properties describing the platform's capabilities for objects.</span>
					<div class="label">has properties:</div>
					<ul>
						<li class="object">
							<div class="name">defineProperty</div>
							<span>(optional) An object containing properties describing the platform's meta-object capabilities.</span>
							<div class="label">has properties:</div>
							<ul>
								<li class="value">
									<div class="name">ecma</div>
									<span class="type">boolean</span>
									<span>
										(conditional) If <code>true</code>, the platform supports the ECMA-262 version 5
										<code>Object.defineProperty</code> method.
									</span>
								</li>
								<li class="value">
									<div class="name">accessor</div>
									<span class="type">boolean</span>
									<span>
										(conditional) If <code>true</code>, the platform supports <code>__defineGetter__</code> and
										<code>__defineSetter__</code> as defined by Mozilla.
									</span>
								</li>
								<li class="function" jsapi:id="$platform.Object.defineProperty.setReadOnly">
									<div class="name"><a name="$platform.Object.defineProperty.setReadOnly">setReadOnly</a></div>
									<span>(conditional; depends on platform support) Sets whether a named property on an object is read-only.</span>
									<div class="arguments">
										<div class="label">Arguments</div>
										<ol>
											<li class="value">
												<span class="type">object</span>
												<span>An object.</span>
											</li>
											<li class="value">
												<span class="type">string</span>
												<span>The name of a property.</span>
											</li>
											<li class="value">
												<span class="type">boolean</span>
												<span>
													Whether the property should be read-only (<code>true</code>) or writable
													(<code>false</code>).
												</span>
											</li>
										</ol>
									</div>
									<script type="application/x.jsapi#tests"><![CDATA[
										var o = {};
										o.x = 3;
										verify(o).x.is(3);
										o.x = 4;
										verify(o).x.is(4);
										var setReadOnly = (function() {
											if ($platform.Object.defineProperty && $platform.Object.defineProperty.setReadOnly) {
												return $platform.Object.defineProperty.setReadOnly;
											}
										})();
										if (setReadOnly) {
											setReadOnly(o,"x",true);
											o.x = 5;
											verify(o).x.is(4);
											setReadOnly(o,"x",false);
											o.x = 5;
											verify(o).x.is(5);
										}
									]]></script>
								</li>
							</ul>
						</li>
					</ul>
				</li>
				<li class="object">
					<div class="name">java</div>
					<span>(conditional) An object with properties describing the platform's Java/LiveConnect capabilities.</span>
					<div class="label">has properties:</div>
					<ul>
						<li class="function">
							<div class="name">getClass</div>
							<div class="arguments">
								<div class="label">Arguments</div>
								<ol>
									<li class="value">
										<span class="type">string</span>
										<span>A Java class name.</span>
									</li>
								</ol>
							</div>
							<div class="returns">
								<div class="label">Returns</div>
								<span class="type">JavaClass</span>
								<span>
									A <code>JavaClass</code> object representing the class with the given name, or <code>null</code>
									if no class by that name can be loaded.
								</span>
							</div>
						</li>
					</ul>
				</li>
				<li class="constructor">
					<div class="name"><a name="$platform.MetaObject">MetaObject</a></div>
					<span>(conditional; depends on platform support) A metaobject implementation.</span>
					<div class="arguments">
						<div class="label">Arguments</div>
						<ol>
							<li class="object">
								<div class="label">has properties:</div>
								<ul>
									<li class="value">
										<div class="name">delegate</div>
										<span class="type">object</span>
										<span>
											A delegate object that will be used to supply implementations for properties in
											preference to using the meta-object implementations.
										</span>
									</li>
									<li class="function">
										<div class="name">get</div>
										<span>
											A function that will be called when one of this object's properties that is not defined
											by the delegate object is accessed. This object will be provided as the <code>this</code>
											argument.
										</span>
										<div class="arguments">
											<div class="label">Arguments</div>
											<ol>
												<li class="value">
													<span class="type">string</span>
													<span>A property name</span>
												</li>
											</ol>
										</div>
										<div class="returns">
											<div class="label">Returns</div>
											<span>A value for the named property.</span>
										</div>
									</li>
									<li class="function">
										<div class="name">set</div>
										<span>
											A function that will be called when one of this object's properties that is not defined by
											the delegate object is set. This object will be provided as the <code>this</code> argument.
										</span>
										<div class="arguments">
											<div class="label">Arguments</div>
											<ol>
												<li class="value">
													<span class="type">string</span>
													<span>A property name.</span>
												</li>
												<li class="value">
													<span>The value assigned to the named property.</span>
												</li>
											</ol>
										</div>
									</li>
								</ul>
							</li>
						</ol>
					</div>
					<div class="instances">
						<div class="label">Instances</div>
						<span class="type">object</span>
						<span>
							Returns an object that uses the given delegate object to supply properties, but uses the given
							getter and setter if the delegate is <code>null</code> or the delegate lacks the named property.
						</span>
					</div>
					<script type="application/x.jsapi#initialize">
						scope.MetaObject = $platform.MetaObject;
					</script>
					<script type="application/x.jsapi#tests" jsapi:id="$platform.MetaObject">
						if ($platform.MetaObject) {
							var doubler = function(name) {
								if (isNaN(Number(name))) {
									return name + name;
								} else {
									return Number(name) * 2;
								}
							}

							var a = new $platform.MetaObject({ get: doubler });
							test( a[1] == 2 );
							test( a.name == "namename" );

							var logger = new function() {
								var log = [];

								this.log = log;

								this.setter = function(name,value) {
									log.push({ target: this, name: name, value: value });

									this[name] = value;
								}
							}

							var $b = {};
							var b = new $platform.MetaObject({ delegate: $b, get: null, set: logger.setter });
							b.foo = "bar";
							test( logger.log[0].target == $b );
							test( logger.log[0].name == "foo" );
							test( logger.log[0].value == "bar" );
						}
					</script>
				</li>
			</ul>
		</div>
	</div>
</body>
</html>