<!--
LICENSE
This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not
distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.

The Original Code is the rhino/file SLIME module.

The Initial Developer of the Original Code is David P. Caldwell <david@davidpcaldwell.com>.
Portions created by the Initial Developer are Copyright (C) 2013 the Initial Developer. All Rights Reserved.

Contributor(s):
END LICENSE
-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:jsapi="http://www.inonit.com/jsapi">
<!--	Template for IDE for creating api.html	-->
<head>
	<title>list(): Listing directories</title>
	<link rel="stylesheet" type="text/css" href="../../loader/api/api.css"></link>
	<script type="text/javascript" src="../../loader/api/api.js"></script>
</head>
<body>
	<div class="function" jsapi:id="method">
		<div class="name">list</div>
		<div class="arguments">
			<div class="label">Arguments</div>
			<ol>
				<li class="object">
					<div class="label">has properties:</div>
					<ul>
						<li class="value">
							<div class="name">filter</div>
							<span class="type">function</span>
							-OR-
							<span class="type">RegExp</span>
							(optional) Used to filter the results of listing this directory.
							Nodes that the filter does not accept will not be returned (but if they are directories, their contents
							may still be returned; see <code>descendants</code>).
							<div class="function">
								If this property is a <code>function</code>, it will be invoked for each node
								found:
								<div class="arguments">
									<div class="label">Arguments</div>
									<ol>
										<li class="value">
											<span class="type"><a href="api.html#types.node">node</a></span>
											<span>A node found when listing this directory.</span>
										</li>
									</ol>
								</div>
								<div class="returns">
									<div class="label">Returns</div>
									<span class="type">boolean</span>
									<span><code>true</code> to include this node, <code>false</code> to exclude it.</span>
								</div>
							</div>
							<div>
								If this property is a <code>RegExp</code>, the <code>basename</code> (see
								<a href="#types.Pathname">Pathname</a>) of each node will be tested against the
								<code>RegExp</code> and only those that match will be returned; those that do
								not match will be excluded.
							</div>
						</li>
						<li class="function">
							<div class="name">descendants</div>
							<span>
								(optional; if absent, subdirectories will not be searched)
								Specifies whether to search descendant directories when listing this directory.
							</span>
							<div class="arguments">
								<div class="label">Arguments</div>
								<ol>
									<li class="value">
										<span class="type"><a href="api.html#types.directory">directory</a></span>
										<span>A directory.</span>
									</li>
								</ol>
							</div>
							<div class="returns">
								<div class="label">Returns</div>
								<span class="type">boolean</span>
								<span>
									<code>true</code> to indicate the contents of this directory should be processed;
									<code>false</code> to indicate the directory should not be processed.
								</span>
							</div>
						</li>
						<li class="value">
							<div class="name">type</div>
							<span class="type">property of this function</span>
							<span>
								Specifies whether to return <a href="api.html#types.node">node</a> objects from this
								method, or to return objects describing the directory contents more fully
								(see below).
							</span>
						</li>
					</ul>
				</li>
			</ol>
		</div>
		<div class="returns">
			<div class="label">Returns</div>
			<span class="type">Array of specified type: <a href="api.html#types.node">node</a> or entry.</span>
		</div>
		<div class="label">has properties:</div>
		<ul>
			<li class="value">
				<div class="name">NODE</div>
				<span>The method should return objects of type <a href="api.html#types.node">node</a>.</span>
			</li>
			<li class="value">
				<div class="name">ENTRY</div>
				<span>The method should return objects of the following type:</span>
				<div class="label">has properties:</div>
				<ul>
					<li class="value">
						<div class="name">path</div>
						<span class="type">string</span>
						<span>The path, relative to this directory, at which this node can be found.</span>
					</li>
					<li class="value">
						<div class="name">node</div>
						<span class="type"><a href="api.html#types.node">node</a></span>
					</li>
				</ul>
			</li>
			<li class="value">
				<div class="name">RESOURCE</div>
				<span>The method should return objects of the following type:</span>
				<div class="label">has properties:</div>
				<ul>
					<li class="value">
						<div class="name">path</div>
						<span class="type">string</span>
						<span>
							The path, relative to this directory, at which this node can be found, delimited
							by forward slashes regardless of the underlying filesystem.
						</span>
					</li>
					<li class="value">
						<div class="name">resource</div>
						<span class="type">
							<a href="../../rhino/io/api.html#Resource">Resource</a>
							with second argument to write having semantics of
							the second argument to
							<a href="api.html#types.Pathname">Pathname</a>.write()
						</span>
					</li>
				</ul>
			</li>
			<!--
					TODO	add RESOURCE that returns an array of path/resource? easy descriptor, would
							probably then exclude directories explicitly and this could be used as easy input
							to lots of things logically representing trees.
			-->
		</ul>
		<script type="application/x.jsapi#tests"><![CDATA[
			var filesystem = (module.filesystems.cygwin) ? module.filesystems.cygwin : module.filesystems.os;
			var dir = newTemporaryDirectory(filesystem);

			var filea = createFile(dir,"a");
			var fileb = createFile(dir,"b");
			var filec = createDirectory(dir,"c");
			var filed = createFile(filec,"d");
			var filee = createDirectory(dir,"e");
			var filef = createFile(filee,"f");

			createFile(dir,"target",1112);

			var NODE = dir.list.NODE;
			var ENTRY = dir.list.ENTRY;
			var RESOURCE = dir.list.RESOURCE;

			test(dir.list().length == 5);

			test( dir.list({ filter: /^.$/ }).length == 4 );
			test( dir.list({ filter: /../ }).length == 1 );
			test( dir.list({ filter: /a/ }).length == 2 );
			test( dir.list({ filter: /ar/ }).length == 1 );
			test( dir.list({ filter: /foobar/ }).length == 0 );

			var descendants = {
				all: function(dir) {
					return true;
				}
			}
			test( dir.list({ descendants: descendants.all }).length == 7 );
			test( dir.list({ filter: /c/, descendants: descendants.all }).length == 1 );
			test( dir.list({ filter: /d/, descendants: descendants.all }).length == 1 );

			var filter = function(node) {
				var basename = node.pathname.basename;
				if (basename == "a") return true;
				if (basename == "b") return true;
				if (basename == "c") return false;
				if (basename == "d") return true;
				if (basename == "e") return false;
				if (basename == "f") return true;
				if (basename == "target") return false;
			};
			test(dir.list({ filter: filter, descendants: function(dir) {
				if (dir.pathname.basename == "c") return true;
				return filter(dir);
			} }).length == 3);

			var e_entries = filee.list({ type: ENTRY });
			test(e_entries.length == 1);
			test(e_entries[0].node.pathname.basename == "f");
			test(e_entries[0].path == "f");

			var entries = dir.list({ type: ENTRY, descendants: descendants.all });
			var entryf = entries.filter( function(entry) {
				return entry.path == ["e","f"].join(filesystem.$unit.getPathnameSeparator());
			} );
			test(entryf.length == 1);
			var entrye = entries.filter( function(entry) {
				return entry.path == "e" + filesystem.$unit.getPathnameSeparator();
			} );
			test(entrye.length == 1);
			entryf = entryf[0];
			test(entryf.node.pathname.basename == "f");

			var resources = dir.list({ type: RESOURCE, descendants: descendants.all });
			var resourcef = resources.filter( function(resource) {
				return resource.path == "e/f";
			} );
			test(resourcef.length == 1);
			resourcef = resourcef[0];
			test(resourcef.resource.read(String) == "");

			test(
				dir.list({
					filter: function(node) {
						return true;
					},
					descendants: function(node) {
						return true;
					}
				}).length == 7
			);

			if (context.cygwin) {
				debugger;
				var link = function(target,link) {
					jsh.shell.shell(
						jsh.file.Pathname("/bin/ln"),
						[
							"-s",
							target.toString(),
							link.toString()
						],
						{
						}
					);
				};

				var dir = jsh.shell.TMPDIR.createTemporary({ directory: true });

				var newFile = function(path) {
					dir.getRelativePath(path).write(path, { append: false });
					return dir.getFile(path);
				}

				var newDir = function(path) {
					return dir.getRelativePath(path).createDirectory();
				}

				var dirtarget = newDir("dirtarget");
				var filetarget = newFile("filetarget");

				var list = newDir("list");
				link(dirtarget.pathname,list.getRelativePath("softdir"));
				link(filetarget.pathname,list.getRelativePath("softfile"));
				var hardfile = newFile("list/hardfile");
				var harddir = newDir("list/harddir");

				test(list.list().length == 4);
				var nodes = list.list();
				nodes.sort(function(a,b) {
					if (a.pathname.basename < b.pathname.basename) return -1;
					if (b.pathname.basename < a.pathname.basename) return 1;
					return 0;
				});
				var getWindowsTargetName = function(node) {
					var winpath = module.filesystems.cygwin.toWindows(node.pathname);
					return winpath.toString().split("\\").slice(-1)[0];
				}
				test(getWindowsTargetName(nodes[0]) == "harddir");
				test(getWindowsTargetName(nodes[1]) == "hardfile");
				test(getWindowsTargetName(nodes[2]) == "dirtarget");
				test(getWindowsTargetName(nodes[3]) == "filetarget");
			}
		]]></script>
	</div>
</body>
</html>