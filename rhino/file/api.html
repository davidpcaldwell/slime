<!--
LICENSE
This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not
distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.

END LICENSE
-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:jsapi="http://www.inonit.com/jsapi">
<head>
	<title>Filesystem API</title>
	<link rel="stylesheet" type="text/css" href="../../loader/api/api.css"></link>
	<script type="text/javascript" src="../../loader/api/api.js"></script>
</head>
<body>
	<script type="application/x.jsapi#initialize"><![CDATA[
		var $Context = function(p) {
			this.api = arguments.callee.api;
			if (jsh.shell.environment.PATHEXT) {
				this.pathext = jsh.shell.environment.PATHEXT.split(";");
			}
			this.$pwd = String(jsh.shell.properties.object.user.dir);
			this.$slime = jsh.unit.$slime;
			this.addFinalizer = jsh.loader.addFinalizer;

			if (p && p.cygwin) {
				//	TODO	switch to use appropriate jsh properties, rather than accessing Java system properties directly
				var System = Packages.java.lang.System;
				this.cygwin = {
					root: String( System.getProperty("cygwin.root") )
				};
				if (System.getProperty("cygwin.paths")) {
					//	Using the paths helper currently does not seem to work in the embedded situation when running inside
					//	the SDK server
					//	TODO	check this
					this.cygwin.paths = String( System.getProperty("cygwin.paths") );
				}
			}

			this.$Context = arguments.callee;
		}
		$Context.api = new function() {
			this.js = $jsapi.loader.module("../../js/object/");
			var java = $jsapi.loader.module("../../jrunscript/host/", {
				$slime: jsh.unit.$slime,
				logging: {
					prefix: "slime.jrunscript.file.test"
				}
			});
			this.java = java;
			this.io = $jsapi.loader.module("../../jrunscript/io/", {
				$slime: jsh.unit.$slime
				,api: {
					java: java,
					mime: jsh.unit.$slime.mime
				}
			});
		}

// 		var rv = [ new $Context() ];
// 		if (Packages.java.lang.System.getProperty("cygwin.root")) {
// 			rv.push(new $Context({ cygwin: true }));
// 		}
// 		return rv;
		scope.context = new $Context();
		scope.module = $jsapi.loader.module("module.js", scope.context);
	]]></script>
	<div>
		<h1>Context</h1>
		<!--	TODO	add round of tests using cygwin.root but not cygwin.paths?	-->
		<script type="application/x.jsapi#context"><![CDATA[
			(function() {
				var $Context = function(p) {
					this.api = arguments.callee.api;
					if (jsh.shell.environment.PATHEXT) {
						this.pathext = jsh.shell.environment.PATHEXT.split(";");
					}
					this.$pwd = String(jsh.shell.properties.object.user.dir);
					this.$rhino = jsh.unit.$slime;
					this.addFinalizer = jsh.loader.addFinalizer;

					if (p && p.cygwin) {
						//	TODO	switch to use appropriate jsh properties, rather than accessing Java system properties directly
						var System = Packages.java.lang.System;
						this.cygwin = {
							root: String( System.getProperty("cygwin.root") )
						};
						if (System.getProperty("cygwin.paths")) {
							//	Using the paths helper currently does not seem to work in the embedded situation when running inside
							//	the SDK server
							//	TODO	check this
							this.cygwin.paths = String( System.getProperty("cygwin.paths") );
						}
					}

					this.$Context = arguments.callee;
				}
				$Context.api = new function() {
					this.js = $jsapi.loader.module("../../js/object/");
					var java = $jsapi.loader.module("../../jrunscript/host/", {
						$rhino: jsh.unit.$slime
					});
					this.java = java;
					this.io = $jsapi.loader.module("../../jrunscript/io/", {
						$java: new Packages.inonit.script.runtime.io.Streams()
						,$rhino: jsh.unit.$slime
						,api: {
							java: java,
							mime: jsh.unit.$slime.mime
						}
					});
				}

				var rv = [ new $Context() ];
				if (Packages.java.lang.System.getProperty("cygwin.root")) {
					rv.push(new $Context({ cygwin: true }));
				}
				return rv;
			})()
		]]></script>
	</div>
	<div>
		<h1>Exports</h1>
		<script type="application/x.jsapi#initialize"><![CDATA[
			scope.helpers = new function() {
				var module;

				this.initialize = function() {
					module = arguments[0];
					scope.filesystem = (module.filesystems.cygwin) ? module.filesystems.cygwin : module.filesystems.os;
				}

				//	Although this is equivalent to jsh.file.TMP.createTemporary({ directory: true }), we use a separate copy here because we want the
				//	calls to go to the module being tested, not the module executing the test environment
				this.newTemporaryDirectory = function() {
					var $dir = scope.$jsapi.java.io.newTemporaryDirectory();
					return scope.filesystem.java.adapt($dir).directory;
//					return scope.filesystem.$unit.Pathname(scope.filesystem.$unit.getNode($dir)).directory;
				}

				this.createFile = function(base,name,length) {
					var pathname = base.getRelativePath(name);
					//	Why the below is qualified with 'this' is a little mysterious
					if (true) {
						//	NASHORN	Nashorn requires the use of scope to access context, even though when scope.createFile is
						//			invoked below, scope should == this. In Rhino it does, but in Nashorn it does not.
						var out = pathname.write(scope.context.$Context.api.io.Streams.binary);
					} else {
						var out = pathname.write(this.context.$Context.api.io.Streams.binary);
					}
					if (length) {
						for (var i=0; i<length; i++) {
							out.java.adapt().write(0);
						}
					}
					out.close();
					return pathname.file;
				}

				this.createDirectory = function(base,name) {
					return base.getRelativePath(name).createDirectory();
				}
			}

			scope.newTemporaryDirectory = scope.helpers.newTemporaryDirectory;
			scope.createFile = scope.helpers.createFile;
			scope.createDirectory = scope.helpers.createDirectory;

			scope.expectError = function(test,f,expect) {
				if (typeof(expect) == "undefined") {
					expect = true;
				}
				var invoke = function() {
					try {
						f();
						test(!expect);
					} catch (e) {
						test(expect);
					}
				};
				(function() {
					if (expect) {
						$api.debug.disableBreakOnExceptionsFor(invoke)();
					} else {
						invoke();
					}
				})();
			}
		]]></script>
		<script type="application/x.jsapi#initialize"><![CDATA[
			scope.helpers.initialize(scope.module);
		]]></script>
		<ul>
			<li class="function" jsapi:id="Pathname">
				<div class="name">Pathname</div>
				<div class="type">
					<a class="type" name="types.node">node</a>
					<div class="label">has properties:</div>
					<ul>
						<li class="function" jsapi:id="copy">
							<div class="name">copy</div>
							<div class="arguments">
								<div class="label">Arguments</div>
								<ol>
									<li class="value">
										<span class="type"><a href="#types.pathname">Pathname</a></span>
										or <span class="type"><a href="#types.directory">directory</a></span>
										<span>
											A location to which to copy this node. If the given location is a
											<a href="#types.directory">directory</a>, the node will be copied into that directory
											with this node's basename. If the given location is a
											<a href="#types.Pathname">Pathname</a>,
											the node will be copied to the
											given <code>Pathname</code>.
										</span>
									</li>
									<li class="object">
										<span>(optional) An object whose properties specify the operation of this method.</span>
										<div class="label">has properties:</div>
										<ul>
											<li class="value" jsapi:id="recursive">
												<div class="name">recursive</div>
												<span class="type">boolean</span>
												<span>
													If <code>true</code>, then if the parent directory or directories to which this
													file would be copied do not exist, they will be created. Otherwise, if they do
													not exist, an exception will be thrown.
												</span>
											</li>
											<li class="function" jsapi:id="filter">
												<!--	TODO	should harmonize this concept with the same concept in list()	-->
												<div class="name">filter</div>
												<span>
													(optional)
													A function that specifies which nodes to copy. For an ordinary
													file, this function will be invoked once with the given file; for a directory,
													it will be invoked for the directory and then recursively for its contents.
													If omitted, an implementation will be supplied that copies all nodes unless
													there is an existing node at the given location, in which case it will throw
													an exception.
												</span>
												<div class="arguments">
													<div class="label">Arguments</div>
													<ol>
														<li class="object">
															<span>
																An argument with properties describing a node to copy.
															</span>
															<div class="label">has properties:</div>
															<ul>
																<li class="value">
																	<div class="name">entry</div>
																	<span class="type"><a href="#types.node.entry">node.entry</a></span>
																	<span>
																		The entry to copy, relative to the node on which the
																		<code>copy()</code> method was invoked.
																	</span>
																</li>
																<li class="value">
																	<div class="name">exists</div>
																	<span class="type"><a href="#types.node">node</a></span>
																	<span>
																		The node, if any, that already exists at the destination to
																		which this node will be copied.
																	</span>
																</li>
															</ul>
														</li>
													</ol>
												</div>
												<div class="returns">
													<div class="label">Returns</div>
													<span class="type">boolean</span>
													<div>
														If <code>true</code> is returned, then if this node is an ordinary file, it
														will be copied, overwriting the file at the given location. If it is a
														directory, then the directory will be created; if it already exists, no
														action will be taken.
													</div>
													<div>
														If <code>false</code> is returned, then for ordinary files; no action will
														be taken. For directories, not only will no action be taken, but the
														contents of the given directory will not be processed.
													</div>
												</div>
											</li>
										</ul>
									</li>
								</ol>
							</div>
							<div class="returns">
								<div class="label">Returns</div>
								<span class="type"><a href="#types.node">node</a></span>
								<span>The node created by this copy.</span>
							</div>
							<div class="label">has properties:</div>
							<ul>
								<li class="object">
									<div class="name">filter</div>
									<span>
										An object whose properties supply implementations suitable for use as the
										<code>filter</code> property of the mode argument of <code>copy</code>.
									</span>
									<div class="label">has properties:</div>
									<ul>
										<li class="value">
											<div class="name">OVERWRITE</div>
											<span class="type">function suitable for use as value for <code>filter</code></span>
											<span>Implementation that always overwrites the given files and directories.</span>
										</li>
									</ul>
								</li>
							</ul>
						</li>
					</ul>
				</div>
				<div class="type" jsapi:id="file">
					<a class="type" name="types.file">file</a>
					<div>
						<span class="type">supports <a href="#types.node">node</a></span>
						<span class="type">supports <a href="../../loader/jrunscript/api.html#$exports.Resource">Java Resource</a></span>
					</div>
					<div class="label">has properties:</div>
					<ul>
						<li class="value">
							<div class="name">length</div>
							<span class="type">number</span>
							<span>The size of this file, in bytes.</span>
						</li>
						<li class="function">
							<div class="name">read</div>
							<span>
								Opens this file for reading.
							</span>
							<div class="arguments">
								<div class="label">Arguments</div>
								<ol>
									<li class="value">
										<div>
											An argument specifying how the caller wants to read the file. The following arguments
											are allowed. If the argument is:
											<ul>
												<li>
													<code>Streams.binary</code>, <code>read</code> will return a
													<code>jrunscript/io</code> <i>binary input stream</i> which can be used to read the
													file.
												</li>
												<li>
													<code>Streams.text</code>, <code>read</code> will return a
													<code>jrunscript/io</code> <i>character input stream</i> which can be used to read the
													file.
												</li>
												<li>
													The global function <code>String</code>, <code>read</code> will read the entire
													file into a <code>string</code> and return it.
												</li>
												<li>
													The global function <code>XML</code>, <code>read</code> will read the entire
													file into an <code>XMLList</code> and return it.
												</li>
											</ul>
										</div>
									</li>
								</ol>
							</div>
							<div class="returns">
								<div class="label">Returns</div>
								<span>
									Either the content of the file or a stream for reading that content, depending on its
									arguments: see above.
								</span>
							</div>
						</li>
						<!--
						<li class="function">
							<div class="name">readLines</div>
							<span>Convenience for <code>read(Streams.text).readLines()</code>.</span>
						</li>
						-->
					</ul>
				</div>
				<div class="type">
					<a class="type" name="types.directory">directory</a>
					<span>An object representing a directory in the local file system.</span>
					<div>
						<span class="type">supports <a href="#types.node">node</a></span>
					</div>
					<div class="label">has properties:</div>
					<ul>
						<li class="function">
							<div class="name">getFile</div>
							<div class="arguments">
								<div class="label">Arguments</div>
								<ol>
									<li class="value">
										<span class="type">string</span>
										<span>A filesystem path relative to this directory</span>
									</li>
								</ol>
							</div>
							<div class="returns">
								<div class="label">Returns</div>
								<span class="type"><a href="#types.file">file</a></span>
								<span>
									A file that can be found at the given location, or <code>null</code> if no (non-directory) file
									exists at that location.
								</span>
							</div>
						</li>
						<li class="function">
							<div class="name">getSubdirectory</div>
							<div class="arguments">
								<div class="label">Arguments</div>
								<ol>
									<li class="value">
										<span class="type">string</span>
										<span>A relative path</span>
									</li>
								</ol>
							</div>
							<div class="returns">
								<div class="label">Returns</div>
								<span class="type"><a href="#types.directory">directory</a></span>
								<span>
									A subdirectory that can be found at the given location relative to this directory, or
									<code>null</code> if no directory exists at that location.
								</span>
							</div>
						</li>
					</ul>
				</div>
			</li>
			<!-- TODO: below replaced by experimental navigate() -->
			<!-- <li class="function">
				<div class="name">getRelativePathTo</div>
				<span>__DESCRIPTION__</span>
				<div class="arguments">
					<div class="label">Arguments</div>
					<ol>
					</ol>
				</div>
				<div class="returns">
					<div class="label">Returns</div>
					<span class="type">__TYPE__</span>
					<span>__DESCRIPTION__</span>
				</div>
				<script type="application/x.jsapi#tests" jsapi:id="getRelativePath">
					var relative = module.getRelativePathTo(
						jsh.shell.jsh.src.getFile("loader/expression.js")
					)(jsh.shell.jsh.src.getFile("rhino/file/api.html"));
					verify(relative).is("../../loader/expression.js");
				</script>
			</li> -->
		</ul>
		<script type="application/x.jsapi#initialize">
			var _context = new function() {
				var module = scope.module;
				this.filesystem = (module.filesystems.cygwin) ? module.filesystems.cygwin : module.filesystems.os;
				this.dir = scope.newTemporaryDirectory(this.filesystem);
				this.module = { Streams: scope.context.$Context.api.io.Streams };
			}
			if (!_context.dir) throw new Error("Missing context.dir");
			var filesystem = _context.filesystem;

			var dir = _context.dir.getRelativePath("filetests").createDirectory();

			var createFile = scope.createFile;
			var createDirectory = scope.createDirectory;

			var filea = createFile(dir,"a");
			var fileb = createFile(dir,"b");
			var filec = createDirectory(dir,"c");
			var filed = createFile(filec,"d");
			var filee = createDirectory(dir,"e");
			var filef = createFile(filee,"f");

			scope._context = _context;

			scope.createFile(dir,"target",1112);

			scope.filesystem = filesystem;
			scope.dir = dir;
			scope.filea = filea;
			scope.fileb = fileb;
			scope.filec = filec;
			scope.filed = filed;
			scope.filee = filee;
			scope.filef = filef;
		</script>
		<div jsapi:id="softlink">
			//	TODO	softlinks could be much more thoroughly tested; many scenarios not covered including move, copy
			<script type="application/x.jsapi#initialize">
				var module = scope.module;
				var filesystem = scope.filesystem;
				var createFile = scope.createFile;
				var createDirectory = scope.createDirectory;

				if (jsh.shell.PATH.getCommand("ln")) {
					var tmpdir = scope.$jsapi.java.io.newTemporaryDirectory();
					var hostdir = new Packages.java.io.File(tmpdir, "hostdir");
					hostdir.mkdirs();
					var linkdir = new Packages.java.io.File( tmpdir, "linkdir" );
					linkdir.mkdirs();
					var linkpathname = filesystem.java.adapt(linkdir);
					var hostpathname = filesystem.java.adapt(hostdir);
					var target = createFile(hostpathname.directory,"target",1112);
					var c = createDirectory(hostpathname.directory,"c");

					var shell = function(command,args) {
						Packages.inonit.system.OperatingSystem.get().execute( command, args ).evaluate();
					}

					var LN_PATH;
					if (module.filesystems.cygwin) {
						LN_PATH="c:/cygwin/bin/ln";
					} else {
						LN_PATH="/bin/ln";
					}
					shell(LN_PATH, [ "-s",
						hostpathname.directory.getRelativePath("target").toString(),
						linkpathname.directory.getRelativePath("to_target").toString()
					] );
					shell(LN_PATH, [ "-s",
						hostpathname.directory.getRelativePath("c").toString(),
						linkpathname.directory.getRelativePath("to_c").toString()
					] );
					shell(LN_PATH, [ "-s",
						linkpathname.directory.getRelativePath("to_c").toString(),
						linkpathname.directory.getRelativePath("to_to_c").toString()
					] );
					shell(LN_PATH, [ "-s",
						hostpathname.directory.getRelativePath("does_not_exist").toString(),
						linkpathname.directory.getRelativePath("to_nowhere").toString()
					] );
					scope._linkdir = linkdir;
					scope.linkdir = filesystem.java.adapt(scope._linkdir).directory;
					scope.hostdir = hostdir;
					var _createFile = function(_dir,path) {
						var dir = filesystem.java.adapt(_dir).directory;
						scope.createFile(dir,path);
					}

					scope._createFile = _createFile;

					var before = scope.linkdir.getRelativePath("to_c").directory.list().length;
					scope.before = before;
					scope.filelink = scope.linkdir.getRelativePath("to_target").file;
					scope.dirlink = scope.linkdir.getRelativePath("to_c").directory;
					scope.ln = jsh.shell.PATH.getCommand("ln");
				}
			</script>
			<script type="application/x.jsapi#tests">
				if (scope.ln) {
					test( linkdir != null );
					test( linkdir.directory );

					test( linkdir.getRelativePath("to_target").file != null );

					test( function() {
							var reader = filelink.read(context.$Context.api.io.Streams.binary);
							var instream = reader.java.adapt();
							var len = 0;
							while( instream.read() != -1 ) {
								len++;
							}
							instream.close();
							return len == 1112;
						},
						"file is of correct size."
					);
					test( function() {
							return filelink.parent.toString() == linkdir.toString();
						},
						"Softlink parent works correctly."
					);
					test( !filelink.directory );

					test(linkdir.getRelativePath("to_c").directory != null);
				}
			</script>
			<!--
				var linkToLink = linkdir.getRelativePath("to_to_c").directory;
				test( linkToLink != null );
			-->
			<div>
				<script type="application/x.jsapi#initialize">
					if (scope.ln) {
						var File = Packages.java.io.File;
						scope._createFile( scope.hostdir, "c/c1" );
						scope._createFile( scope.hostdir, "c/c2" );
					}
				</script>
				<script type="application/x.jsapi#tests">
					if (scope.ln) {
						scope.test(linkdir.getRelativePath("to_c").directory.list().length == before+2);
					}
				</script>
			</div>
			<div>
				<!--
						var dirlist;
				-->
				<script type="application/x.jsapi#initialize">
					if (scope.ln) {
						scope.dir = scope.filesystem.java.adapt(scope.hostdir).directory;
						scope.filelink.remove();
						scope.dirlist = scope.dir.getSubdirectory("c").list();
					}
				</script>
				<script type="application/x.jsapi#tests">
					if (scope.ln) {
						scope.test( linkdir.getRelativePath("to_target").file == null );
						scope.test( dir.getRelativePath("target").file != null );
						scope.test( linkdir.getRelativePath("to_c").directory != null );
						linkdir.getRelativePath("to_c").directory.remove();
						verify(dir).getSubdirectory("c").list().length.is(dirlist.length);
						scope.test( dir.getRelativePath("c").directory != null );
						scope.test( linkdir.getRelativePath("to_c").directory == null );
						scope.test( dir.getRelativePath("c").directory != null );
					}
				</script>
			</div>
			<div>
				<script type="application/x.jsapi#tests">
					if (scope.ln) {
						scope.test( linkdir.getRelativePath("to_nowhere").file == null );
						scope.test( linkdir.getRelativePath("to_nowhere").directory == null );
						var list = linkdir.list();
						var toDelete;
						list.forEach(function(item) {
							scope.test(item != null);
							scope.test(item.parent.pathname.toString() == linkdir.pathname.toString());
							scope.test(item.pathname.toString().substring(0,linkdir.pathname.toString().length) == linkdir.pathname.toString());
							scope.test(item.directory === null);
							toDelete = item;
						});
						toDelete.remove();
						scope.test(linkdir.list().length+1 == list.length);
					}
				</script>
			</div>
		</div>
	</div>
</body>
</html>
