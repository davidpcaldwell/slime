//	LICENSE
//	This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not
//	distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
//
//	END LICENSE

namespace slime.jrunscript.shell.run {
	export type Line = {
		line: string
	}

	export interface AskEvents {
		start: {
			pid: number
			kill: () => void
		}

		stdout: Line

		stderr: Line
	}

	//	TODO	right now we only capture output of type string; we could capture binary also
	export interface Output {
		output?: string
		error?: string
	}

	export interface Exit {
		status: number
		stdio?: Output
	}

	export interface TellEvents extends AskEvents {
		exit: Exit
	}

	/**
	 * Represents the result of a mock shell invocation. Currently, if line-based output is provided for a stream, the
	 * string given as part of `exit` is ignored.
	 *
	 * @experimental
	 */
	export interface Mock {
		/**
		 * A mock PID to use; defaults to `0`.
		 */
		pid?: number

		/**
		 * Lines of output generated by the invocation. Output can also be provided for a stream by the properties of `exit.stdio`
		 * if line-based I/O is not needed (or the output is less than one line).
		 */
		lines?: ({ stdout: string } | { stderr: string })[]

		exit: {
			status: number
			/**
			 * The output for the process. Currently, if line-based output is provided for a stream, the value for that strean
			 * is ignored.
			 */
			stdio?: {
				output?: string
				error?: string
			}
		}
	}
}

namespace slime.jrunscript.shell.internal.run {
	export interface Context {
		api: {
			java: slime.jrunscript.host.Exports
			io: slime.jrunscript.io.Exports
			file: slime.jrunscript.file.Exports
		}
	}

	export interface Result {
		status: number
		stdio: slime.jrunscript.shell.run.Output
	}

	export interface OutputDestination {
		stream: slime.jrunscript.runtime.io.OutputStream
		close: () => void
		readText?: () => string
	}

	/**
	 * Extends the standard shell `Stdio` type to make all fields required and add a `close()` method that closes the streams and
	 * returns the output of the program.
	 */
	export type Stdio = Required<slime.jrunscript.shell.Stdio> & { close: () => slime.jrunscript.shell.run.Output }

	export interface Listener {
		close: () => void
	}

	export namespace java {
		export interface Context {
			stdio: internal.run.Stdio
			environment: slime.jrunscript.host.Environment
			directory: slime.jrunscript.file.Directory
		}

		export interface Configuration {
			command: string
			arguments: string[]
		}
	}

	export namespace test {
		export const subject: Exports = (function(fifty: slime.fifty.test.Kit) {
			var script: Script = fifty.$loader.script("run.js");
			return script({
				api: {
					java: fifty.global.jsh.java,
					io: fifty.global.jsh.io,
					file: fifty.global.jsh.file
				}
			});
		//@ts-ignore
		})(fifty);

		export const ls: shell.run.Invocation = (function(fifty: slime.fifty.test.Kit) {
			return {
				context: {
					environment: fifty.global.jsh.shell.environment,
					directory: fifty.jsh.file.object.getRelativePath(".").toString(),
					stdio: {
						input: null,
						output: "string",
						error: fifty.global.jsh.shell.stdio.error
					}
				},
				configuration: {
					command: "ls",
					arguments: []
				}
			};
		//@ts-ignore
		})(fifty);
	}

	export interface Exports {
		question: slime.$api.fp.world.Question<slime.jrunscript.shell.run.Invocation, slime.jrunscript.shell.run.AskEvents, slime.jrunscript.shell.run.Exit>
	}

	(
		function(
			fifty: slime.fifty.test.Kit
		) {
			const { verify } = fifty;
			const { $api } = fifty.global;

			fifty.tests.question = $api.Function.pipe(
				$api.Function.world.ask(
					test.subject.question(test.ls)
				),
				function(exit) {
					verify(exit).status.is(0);
					var listing = exit.stdio.output.split("\n");
					verify(listing).evaluate(function(array) { return array.indexOf("run.fifty.ts") != -1; }).is(true);
					verify(listing).evaluate(function(array) { return array.indexOf("foobar.fifty.ts") != -1; }).is(false);
				}
			)
		}
	//@ts-ignore
	)(fifty);


	export interface Exports {
		run: slime.$api.fp.impure.Action<slime.jrunscript.shell.run.Invocation,slime.jrunscript.shell.run.TellEvents>
	}

	(
		function(
			fifty: slime.fifty.test.Kit
		) {
			const subject = test.subject;
			const { verify, run } = fifty;
			const { jsh } = fifty.global;

			fifty.tests.run = function() {
				run(function() {
					var tell = subject.run(test.ls);

					tell({
						exit: function(e) {
							var listing = e.detail.stdio.output.split("\n");
							listing = listing.slice(0, listing.length-1);
							fifty.verify(e).detail.status.is(0);
							fifty.verify(listing).evaluate(function(array) { return array.indexOf("run.fifty.ts") != -1; }).is(true);
						}
					})
				});

				run(function pwdIsShellWorkingDirectoryIfUnspecified() {
					var PWD = jsh.shell.PWD.pathname.toString();
					var tell = subject.run({
						context: {
							environment: jsh.shell.environment,
							stdio: {
								input: null,
								output: "string",
								error: "line"
							},
							directory: void(0)
						},
						configuration: {
							command: "pwd",
							arguments: []
						}
					});
					tell({
						exit: function(e) {
							verify(e.detail.stdio.output).is(PWD + "\n");
						}
					});
				});
			}
		}
	//@ts-ignore
	)(fifty);

	export interface Exports {
		mock: {
			run: shell.World["mock"]

			tell: shell.Exports["Tell"]["mock"]
		}

		old: {
			buildStdio: (p: slime.jrunscript.shell.run.StdioConfiguration) => (events: slime.$api.Events<slime.jrunscript.shell.run.TellEvents>) => Stdio
			run: (
				context: slime.jrunscript.shell.run.Context,
				configuration: slime.jrunscript.shell.run.Configuration,
				module: {
					events: any
				},
				events: slime.jrunscript.shell.run.old.Events,
				p: slime.jrunscript.shell.run.old.Argument,
				invocation: slime.jrunscript.shell.run.old.Argument,
				isLineListener: (p: slime.jrunscript.shell.invocation.old.OutputStreamConfiguration) => p is slime.jrunscript.shell.invocation.old.OutputStreamToLines
			) => Result
		}
	}

	export type Script = slime.loader.Script<Context,Exports>

	(
		function(
			fifty: slime.fifty.test.Kit
		) {
			fifty.tests.suite = function() {
				fifty.run(fifty.tests.run);
			}
		}
	//@ts-ignore
	)(fifty);
}
