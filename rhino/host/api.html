<!--
LICENSE
This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not
distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.

The Original Code is the rhino/host SLIME module.

The Initial Developer of the Original Code is David P. Caldwell <david@davidpcaldwell.com>.
Portions created by the Initial Developer are Copyright (C) 2010-2013 the Initial Developer. All Rights Reserved.

Contributor(s):
END LICENSE
-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:jsapi="http://www.inonit.com/jsapi">
<head>
	<title>Java host objects</title>
	<link rel="stylesheet" type="text/css" href="../../loader/api/api.css"></link>
	<script type="text/javascript" src="../../loader/api/api.js"></script>
</head>
<body>
	<script type="application/x.jsapi#initialize">
		scope.module = $jsapi.environment.module;
		if (!scope.module) {
			//	Compatibility with old test structure
			scope.module = $jsapi.loader.module("module.js", { $rhino: jsh.$jsapi.$rhino });
		}
	</script>
	<div>
		<h1>Context</h1>
		<ul>
			<li class="value">
				<div class="name">globals</div>
				<!--	<span class="type"></span>	-->
				<span>If <code>true</code>, this module modifies global JavaScript objects.</span>
			</li>
		</ul>
		<script type="application/x.jsapi#context">
			new function() {
				this.$rhino = jsh.$jsapi.$rhino;
			}
		</script>
	</div>
	<div>
		<script type="application/x.jsapi#initialize"><![CDATA[
			scope.isRhino = typeof(Packages.org.mozilla.javascript.Context) == "function"
				&& (Packages.org.mozilla.javascript.Context.getCurrentContext() != null);
		]]></script>
		<h1>Exports</h1>
		<ul>
			<li class="function" jsapi:id="getClass">
				<!--	TODO	Semantics for inner classes unclear	-->
				<div class="name">getClass</div>
				<span>
					Returns a Java class given its name. Note that the name expected is the VM-level class name, not the
					source-level class name. So for inner class <code>Baz</code> of class <code>foo.Bar</code>, the argument given
					should be <code>"foo.Bar$Baz"</code>.
				</span>
				<div class="arguments">
					<div class="label">Arguments</div>
					<ol>
						<li class="value">
							<span class="type">string</span>
							<span>A class name.</span>
						</li>
					</ol>
				</div>
				<div class="returns">
					<div class="label">Returns</div>
					<span class="type">JavaClass</span>
					<span>The JavaClass object with the given name, or <code>null</code> if one does not exist.</span>
				</div>
				<script type="application/x.jsapi#tests">
					test(Boolean(module.getClass("java.lang.Object")));
					test(!Boolean(module.getClass("foo.bar.baz")));
					test(Boolean(module.getClass("inonit.script.runtime.io.Streams")));
					test(Boolean(module.getClass("inonit.script.runtime.io.Streams$Null")));
					test(String(module.getClass("inonit.script.runtime.io.Streams$Null")) == "[JavaClass inonit.script.runtime.io.Streams$Null]");
				</script>
			</li>
			<li class="function">
				<div class="name">isJavaObject</div>
				<div class="arguments">
					<div class="label">Arguments</div>
					<ol>
						<li>A JavaScript value</li>
					</ol>
				</div>
				<div class="returns">
					<div class="label">Returns</div>
					<span class="type">boolean</span> <code>true</code> if the given argument is a Java object, and <code>false</code> if it is
					<code>undefined</code>, <code>null</code>, a JavaScript primitive
					value, or a JavaScript object.
					<!--	TODO	What if it is JavaPackage? JavaClass?	-->
				</div>
				<script type="application/x.jsapi#tests" jsapi:id="isJavaObject"><![CDATA[
					var isJavaObject = module.isJavaObject;
					test(isJavaObject(Packages.java.lang.Runtime.getRuntime()));
					test(isJavaObject(new Packages.java.lang.Object()));
					if (isRhino) {
						test(isJavaObject(new Packages.java.lang.String("hello world")));
						test(isJavaObject(new Packages.java.lang.Integer(4)));
						test(isJavaObject(new Packages.java.lang.Boolean(true)));
					} else {
						//	Nashorn appears to map these to JavaScript types
						//	TODO	clarify and document this
						verify(module).isJavaObject(new Packages.java.lang.String("hello world")).is(false);
						verify(module).isJavaObject(new Packages.java.lang.Integer(4)).is(false);
						verify(module).isJavaObject(new Packages.java.lang.Boolean(true)).is(false);
//						test(!isJavaObject(new Packages.java.lang.String("hello world")));
//						test(!isJavaObject(new Packages.java.lang.Integer(4)));
//						test(!isJavaObject(new Packages.java.lang.Boolean(true)));
					}
					test(isJavaObject(Packages.java.lang.Character.UnicodeBlock.GREEK));
					test(!isJavaObject("hello world"));
					test(!isJavaObject(2));
					test(!isJavaObject(true));
					test(!isJavaObject(2.0));
					var x = {};
					test(!isJavaObject(x.myUndefinedMember));
					test(!isJavaObject(null));
					test(!isJavaObject({}));
					var javaArray = module.Array.create({ array: [null,null,null,null] });
					test(isJavaObject(javaArray));
				]]></script>
			</li>
			<li class="object">
				<div class="name">Array</div>
				<span>Contains methods that operate on Java arrays.</span>
				<div class="label">has properties:</div>
				<ul>
					<li class="function">
						<div class="name">adapt</div>
						<span>Creates a JavaScript array with the same contents as the given Java array.</span>
						<div class="arguments">
							<div class="label">Arguments</div>
							<ol>
								<li class="value">
									<span class="type">java.lang.Object[]</span>
									<span>A Java array.</span>
								</li>
							</ol>
						</div>
						<div class="returns">
							<div class="label">Returns</div>
							<span class="type">Array</span>
							<span>
								<!--	TODO	what if null?	-->
							</span>
						</div>
					</li>
				</ul>
				<script type="application/x.jsapi#tests" jsapi:id="toJsArray"><![CDATA[
					var StringClass = (isRhino) ? Packages.java.lang.String : Packages.java.lang.String.class;
					var javaArray = Packages.java.lang.reflect.Array.newInstance( StringClass, 3 );
					javaArray[0] = "Hello";
					javaArray[1] = "World";
					javaArray[2] = "David";

					var isWord = function(s) { return s + " is a word."; }
					var stringLength = function(s) { return s.length(); }

					var words = module.Array.adapt( javaArray ).map( isWord );
					var lengths = module.Array.adapt( javaArray ).map( stringLength );
					var scriptStrings = module.Array.adapt( javaArray ).map( function(s) { return String(s); } );

					test( words[1] == "World is a word." );
					test( lengths[1] == 5 );
					test( typeof(scriptStrings[0]) == "string" && scriptStrings[0] == "Hello" );

					var array = module.Array.create({ type: Packages.java.lang.Number, array: [1,2,3] });
					verify(array).evaluate(function() { return this.length; }).is(3);
					verify(array).evaluate(function() { return module.isJavaObject(array); }).is(true);
				]]></script>
			</li>
			<li class="object">
				<div class="name">Thread</div>
				<div class="type">
					<a class="type" name="types.thread">thread</a>
					<span>__DESCRIPTION__</span>
					<div class="label">has properties:</div>
					<ul>
						<li class="function">
							<div class="name">join</div>
							<span>Causes the calling thread to block and wait for this thread to terminate (either via the completion of the execution of the
								function or via timing out).
							</span>
						</li>
					</ul>
				</div>
				<span>
					(conditional; not implemented for Nashorn)
					__DESCRIPTION__
				</span>
				<div class="label">has properties:</div>
				<ul>
					<li class="function">
						<div class="name">start</div>
						<span>Starts a thread.</span>
						<div class="arguments">
							<div class="label">Arguments</div>
							<ol>
								<li class="object">
									<div class="label">has properties:</div>
									<ul>
										<li class="function">
											<div class="name">call</div>
											<span>
												A function. The function will be invoked with no arguments and an undefined <code>this</code> value; if
												a specific calling configuration is required, a wrapper function that provides this configuration is required.
											</span>
										</li>
										<li class="value">
											<div class="name">timeout</div>
											<span class="type">number</span>
											<span>
												(optional)
												A timeout, in milliseconds.
											</span>
										</li>
										<li class="object">
											<div class="name">on</div>
											<span>
												(optional)
												Specifies a set of callbacks.
											</span>
											<div class="label">has properties:</div>
											<ul>
												<li class="function">
													<div class="name">result</div>
													<span>
														(optional)
														A function invoked when the function executed by the thread returns.
													</span>
													<div class="arguments">
														<div class="label">Arguments</div>
														<ol>
															<li class="value">
																<span>The value returned by the function.</span>
															</li>
														</ol>
													</div>
												</li>
												<li class="function">
													<div class="name">error</div>
													<span>
														(optional)
														A function invoked if the function executed by the thread throws an exception.
													</span>
													<div class="arguments">
														<div class="label">Arguments</div>
														<ol>
															<li class="value">
																<span>The JavaScript value thrown.</span>
															</li>
														</ol>
													</div>
												</li>
												<li class="function">
													<div class="name">timeout</div>
													<span>
														(optional)
														A function invoked if the function executed by the thread times out. This function must
														do any cleanup desired to terminate the executing function; the function will otherwise continue
														executing in the background.
													</span>
												</li>
											</ul>
										</li>
									</ul>
								</li>
							</ol>
						</div>
						<div class="returns">
							<div class="label">Returns</div>
							<span class="type"><a href="#types.thread">thread</a></span>
						</div>
					</li>
					<li class="function">
						<div class="name">run</div>
						<span>Runs a function in a separate thread, but blocks the calling thread until the function completes or times out.</span>
						<div class="arguments">
							<div class="label">Arguments</div>
							<ol>
								<li class="object">
									<span>__DESCRIPTION__</span>
									<div class="label">has properties:</div>
									<ul>
										<li class="function">
											<div class="name">call</div>
											<span>__DESCRIPTION__</span>
										</li>
										<li class="value">
											<div class="name">timeout</div>
											<span class="type">number</span>
											<span>
												(optional)
												A timeout, in milliseconds.
											</span>
										</li>
									</ul>
								</li>
							</ol>
						</div>
						<div class="returns">
							<div class="label">Returns</div>
							<span>The value returned by the underlying function specified by <code>call</code>.</span>
						</div>
					</li>
					<li class="constructor">
						<div class="name">Monitor</div>
						<span>Represents a Java monitor that can be used for synchronization.</span>
						<div class="instances">
							<div class="label">Instances</div>
							<div class="label">has properties:</div>
							<ul>
								<li class="constructor">
									<div class="name">Waiter</div>
									<span>
										Creates a function that waits on its parent monitor until a condition is true, and then executes an underlying
										function.
									</span>
									<div class="arguments">
										<div class="label">Arguments</div>
										<ol>
											<li class="object">
												<span>An object specifying the condition and function.</span>
												<div class="label">has properties:</div>
												<ul>
													<li class="function">
														<div class="name">until</div>
														<span>
															A function that specifies whether the condition has been satisfied. The function will receive
															the <code>this</code> and arguments passed to the function by the caller.
														</span>
														<div class="returns">
															<div class="label">Returns</div>
															<span class="type">boolean</span>
															<span><code>true</code> indicating the condition has been satisfied; <code>false</code> indicating it has not.</span>
														</div>
													</li>
													<li class="function">
														<div class="name">then</div>
														<span>
															A function to execute when the condition has been satisfied. The function will receive the
															<code>this</code> and arguments passed to the function by the caller, and can return any value
															intended to be returned to the caller.
														</span>
													</li>
												</ul>
											</li>
										</ol>
									</div>
									<div class="instances">
										<div class="label">Instances</div>
										<span class="type">function</span>
										<span>
											A function that can be invoked that will invoke <code>until</code> repeatedly and wait on the monitor if it
											returns <code>false</code>; when <code>until</code> returns <code>true</code>, <code>then</code> will be invoked
											and the return value from <code>then</code> returned.
										</span>
									</div>
								</li>
							</ul>
						</div>
						<script type="application/x.jsapi#tests" jsapi:id="Monitor"><![CDATA[
							if (module.Thread) {
								var lock = new module.Thread.Monitor();

								var count = 0;

								var waiter = function() {
									return new lock.Waiter({
										//	TODO	make optional in API with this default implementation
										until: function() {
											return true;
										},
										then: function() {
											test(count == 0);
											count++;
											test(count == 1);
											Packages.java.lang.Thread.sleep(Packages.java.lang.Math.random() * 100);
											count--;
											test(count == 0);
	//											jsh.shell.echo("Success.");
										}
									});
								}

								var waiters = [];
								for (var i=0; i<10; i++) {
									waiters.push(waiter());
								}

								var joiners = [];
								waiters.forEach(function(element) {
									//	jsh.shell.echo("Starting ...");
									var t = module.Thread.start({
										call: element,
										on: {
											result: function(o) {
												//	jsh.shell.echo("Finished.");
												test(true);
											},
											error: function(t) {
												//	jsh.shell.echo("Threw.");
												throw t;
											}
										}
									});
									joiners.push(t);
								});

								joiners.forEach(function(t) {
									t.join();
								});
							}
						]]></script>
					</li>
					<li class="function">
						<div class="name">thisSynchronize</div>
						<span>
							Creates a function whose execution synchronizes on the <code>this</code> object of its invocation.
						</span>
						<div class="arguments">
							<div class="label">Arguments</div>
							<ol>
								<li class="value">
									<span class="type">function</span>
									<span>A function which the returned function should execute.</span>
								</li>
							</ol>
						</div>
						<div class="returns">
							<div class="label">Returns</div>
							<span class="type">function</span>
							<span>
								A function that obtains the lock to its <code>this</code> object, executes the given function, and
								then releases the lock.
							</span>
						</div>
						<script type="application/x.jsapi#tests" jsapi:id="thisSynchronize"><![CDATA[
							if (module.Thread) {
								var f = function(x) {
									return 2*x;
								};

								var s = module.Thread.thisSynchronize(f);

								//	TODO	actually test synchronization

								test(s(2) == 4);
								test(s(4) == 8);

								var debug = function(s) {
		//								Packages.java.lang.System.err.println(s);
								}

								var lock = new Packages.java.lang.Object();

								var finished = 0;

								var inner = function() {
									inner.count++;
									Packages.java.lang.Thread.sleep(100);
									inner.count--;
									finished++;
									this.notifyAll();
								}
								inner.count = 0;

								var nested = module.Thread.thisSynchronize(inner);

								var outer = function() {
									outer.count++;
									nested.call(lock);
									outer.count--;
								}
								outer.count = 0;

								var getCount = module.Thread.thisSynchronize(function() {
									return inner.count;
								});

								var threads = [];
								for (var i=0; i<10; i++) {
									threads.push(module.Thread.start({
										call: outer,
										on: new function() {
											this.returned = function(rv) {
												debug("outer = " + outer.count);
												test(getCount.call(lock) == 0);
											}

											this.threw = function(e) {
												debug("threw = " + e);
												throw e;
											}
										}
									}));
								}

								threads.forEach( function(thread) {
									thread.join();
								});

								test(finished == 10);
							}
						]]></script>
					</li>
					<li class="constructor" jsapi:id="Task">
						<div class="name">Task</div>
						<span>__DESCRIPTION__</span>
						<div class="arguments">
							<div class="label">Arguments</div>
							<ol>
							</ol>
						</div>
						<div class="instances">
							<div class="label">Instances</div>
							<span class="type">__TYPE__</span>
							<span>__DESCRIPTION__</span>
						</div>
						<script type="application/x.jsapi#tests">
							var monitor = new module.Thread.Monitor();
							var task = new module.Thread.Task({
								call: function() {
									return 2*2;
								}
							});
							var events = [];
							var finished;
							task(function(error,returned) {
								monitor.Waiter({
									until: function() {
										return true;
									},
									then: function() {
										events.push(function() {
											finished = returned;
										})
									}
								})();
							});
							while(!finished) {
								monitor.Waiter({
									until: function() {
										return events.length;
									},
									then: function() {
										events.shift()();
									}
								})();
							}
							verify(finished).is(4);
						</script>
						<script type="application/x.jsapi#initialize">
							var module = scope.module;
							var $$api = $jsapi.loader.eval("../../loader/$api.js", {
								$slime: {
									getLoaderScript: function(path) {
										return {
											name: path,
											code: $jsapi.loader.string("../../loader/" + path)
										}
									}
								}
							});
							scope.$$api = $$api;

							var monitor = new module.Thread.Monitor();

							scope.monitor = monitor;

							var Multithreaded = function(step) {
								var Event = function(f) {
									return function(error,returned) {
										monitor.Waiter({
											until: function() {
												return true;
											},
											then: function() {
												f();
											}
										})();
									}
								};

								return {
									toString: function() {
										return step.toString();
									},
									ready: function() {
										return step.ready();
									},
									task: new module.Thread.Task({
										call: Event(step.call)
									})
								};
							}

							scope.A = function(shared) {
								return new Multithreaded({
									ready: function() {
										return true;
									},
									call: function() {
										shared.a = true;
									}
								});
							};
							scope.B = function(shared) {
								return new Multithreaded({
									ready: function() {
										return shared.a;
									},
									call: function() {
										shared.b = true;
									}
								});
							};
							scope.C = function(shared) {
								return new Multithreaded({
									toString: function() {
										return "C";
									},
									ready: function() {
										return false;
									},
									call: function() {
										throw new Error();
									}
								});
							};
						</script>
						<script type="application/x.jsapi#tests">
							var Steps = function() {
								var shared = { a: false, b: false };

								this.shared = shared;
								this.c = new C(shared);

								this.steps = [new A(shared), new B(shared), this.c];

								var unready = [];

								this.unready = unready;

								this.on = {
									unready: function(e) {
										unready.push(e.detail);
									}
								}
							};

							var steps = new Steps();

							var task = $$api.threads.steps.Task(steps);

							var finished = false;

							task(monitor.Waiter({
								until: function() {
									return true;
								},
								then: function() {
									finished = true;
								}
							}));

							monitor.Waiter({
								until: function() {
									return finished;
								},
								then: function() {
								}
							})();

							verify(steps).shared.a.is(true);
							verify(steps).shared.b.is(true);
							verify(steps).unready.length.is(1);
							//	TODO	verify(unready[0]).ready.is(steps.c.ready) does not work because ready property of the
							//			verify object does not have is() method. Probably addressable in unit test framework.
							verify(steps).unready[0].is(steps.c);

							var ssteps = new Steps();
							verify(ssteps).shared.a.is(false);

							var stask = $$api.threads.steps.Task(ssteps);

							stask();

							verify(ssteps).shared.a.is(true);
							verify(ssteps).shared.b.is(true);
							verify(ssteps).unready.length.is(1);
							if (ssteps.unready.length) {
								verify(ssteps).unready[0].is(ssteps.c);
							}
						</script>
					</li>
					<li class="function">
						<div class="name">map</div>
						<span>__DESCRIPTION__</span>
						<div class="arguments">
							<div class="label">Arguments</div>
							<ol>
							</ol>
						</div>
						<div class="returns">
							<div class="label">Returns</div>
							<span class="type">__TYPE__</span>
							<span>__DESCRIPTION__</span>
						</div>
						<script type="application/x.jsapi#tests">
							var array = [1,2,3];
							var doubled = module.Thread.map(array,function(element) {
								return element * 2;
							},null,{
								limit: 2,
								callback: function(result) {
									if (result.threw) {
										jsh.shell.console(result.index + "/" + result.threw.type + ": " + result.threw.message);
										jsh.shell.console(result.stack);
									} else {
										jsh.shell.console(result.index + "/" + result.returned);
									}
								}
							});
							verify(doubled)[0].is(2);
							verify(doubled)[1].is(4);
							verify(doubled)[2].is(6);
						</script>
					</li>
				</ul>
				<script type="application/x.jsapi#tests">
					if (module.Thread) {
						var sleeper = function(length) {
							return function() {
								Packages.java.lang.Thread.sleep(length);
							}
						}

						var f = function() {
							Packages.java.lang.Thread.sleep(100);
							return 1;
						};

						var Callbacks = function() {
							var result;

							this.result = function(v) {
								result = v;
							};

							this.error = function(t) {
								throw t;
							};

							this.timeout = function() {
								result = "Timed out.";
							}

							this.evaluate = function() {
								return result;
							};

							this.getResult = function() {
								return result;
							}
						};

						var c1 = new Callbacks();
						var t1 = module.Thread.start({
							call: f,
							timeout: 150,
							on: c1
						});
						t1.join();
						test(c1.evaluate() == 1);

						//	This test is highly suspect; it essentially hopes that the CPU scheduling happens as expected. Its
						//	chances of passage could be improved by using thread priorities for timeouts, which is probably a good
						//	idea anyway. But perhaps it needs to be re-designed.
						var c2 = new Callbacks();
						var t2 = module.Thread.start({
							call: sleeper(250),
							timeout: 50,
							on: c2
						});
						t2.join();
						verify(c2).getResult().is("Timed out.");

						var r3 = module.Thread.run({
							call: f,
							timeout: 150
						});
						test(r3 == 1);
						try {
							var r4 = module.Thread.run({
								call: sleeper(250),
								timeout: 50
							});
							test(false);
						} catch (e) {
							test(e == module.Thread.run.TIMED_OUT);
						}
					}
				</script>
			</li>
			<!--
				Experimental methods

				fail(): no real specification, no unit tests

				$doc.members.isJavaType = new $Doc.Function({
					summary: "Determines whether a value is a Java host object representing the given type or not.",
					asFunction: {
						description: <>Creates a function which can determines whether a value is a Java object of the given type or not</>,
						arguments: {
							list: [
								{ type: "JavaClass", comment: <>A Rhino <code>JavaClass</code> object, like <code>Packages.java.lang.Object</code></> }
							]
						},
						returns: {
							type: "function",
							comment: <>Returns a function which takes a single argument and returns <code>true</code> if the given argument is an object of the given Java type and <code>false</code> if it is not.</>
						}
					}
				});
				$doc.members.isJavaType.$unit = function(scope) {
					scope.scenario( new function() {
						this.name = "isJavaType";

						this.execute = function(scope) {
							scope.test(module.isJavaType(Packages.java.lang.Object)(new Packages.java.lang.Object()));
							scope.test(!module.isJavaType(Packages.java.lang.Integer)(new Packages.java.lang.Object()));
							scope.test(module.isJavaType(Packages.java.lang.Object)(new Packages.java.lang.Integer(8)));
							scope.test(module.isJavaType(Packages.java.lang.Runnable)(new Packages.java.lang.Thread()));
						}
					})
				}

				scope.scenario( new function() {
					this.name = "Java types";

					this.execute = function(scope) {
						scope.test( module.isJavaType(Packages.java.io.OutputStream)(new Packages.java.io.ByteArrayOutputStream()) );
						scope.test( module.isJavaType(Packages.java.io.OutputStream)(new Packages.java.io.ByteArrayOutputStream()) );
						scope.test( !module.isJavaType(Packages.java.io.InputStream)("Hello") );
					}
				} );
			-->
			<!--
				//	No unit tests!
				$doc.members.toJavaArray = new $Doc.Function({
					summary: <>Converts an ECMAScript array into a Java array</>,
					asFunction: {
						description: <>Converts an ECMAScript array into a Java array</>,
						arguments: {
							list: [
								{ type: <><code>Array</code></>, comment: <>An array to be converted</> },
								{
									type: <>A Java class reference</>,
									comment: <>A reference to a Java class, e.g., <code>Packages.java.lang.Object</code>, representing the type of
										the array to create</>
								}
							]
						},
						returns: {
							type: "A Java array",
							comment: <>A Java array containing the elements in the ECMAScript array.</>
						}
					}
				});
			-->
		</ul>
		<script type="application/x.jsapi#tests" jsapi:id="Properties"><![CDATA[
			var $p = new Packages.java.util.Properties();
			$p.setProperty("a.a", "a");
			$p.setProperty("a.b", "b");
			$p.setProperty("a.c", "c");
			var p = new module.Properties($p);
			//	Note that for-in loop would yield four properties, including toString(), but this seems fine
			Packages.java.lang.System.err.println(Object.keys(p.a));
			test(Object.keys(p.a).length == 3);
		]]></script>
	</div>
</body>
</html>