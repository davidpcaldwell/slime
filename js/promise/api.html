<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:jsapi="http://www.inonit.com/jsapi">
	<head>
		<title>SLIME Promises</title>
		<link href="../../loader/api/api.css" rel="stylesheet" type="text/css" />
		<script src="../../loader/api/api.js"></script>
		<script>
			//	TODO	CORS
			document.domain = document.domain;
		</script>
	</head>
	<body>
		<script type="application/x.jsapi#initialize">
			var unit = $jsapi.loader.file("../../loader/api/unit.js", {
				api: {
					Promise: (function(constant) {
						return function() {
							return constant;
						}
					})(window.Promise)
				},
				log: function() {
					window.console.log.apply(window.console,arguments);
				}
			});
			
			scope.unit = unit;
			
			
			scope.api = $jsapi.loader.file("module.js", {
				Promise: function() {
					return window.Promise;
				}
			});
			
			var browser = $jsapi.loader.module("../../loader/browser/test/module.js", {
				api: {
					unit: unit,
					Promise: window.Promise
				}
			});
			
			scope.browser = browser;
			
			//	TODO	get this to true
			scope.PROMISES_IN_TESTS_ALLOWED = $jsapi.environment.promises;
			
			//	TODO	get this to true
			scope.MULTIPLE_SCENARIOS_ALLOWED = $jsapi.environment.multipleScenarios;
		</script>
		<script type="application/x.jsapi#tests">
			verify(api).evaluate.property("Promise").is.type("function");
			verify(window).evaluate(function() { return this.XMLHttpRequest.asynchrony; }).is.type("object");
			verify(window).evaluate(function() { return this.XMLHttpRequest.asynchrony.started; }).is.type("function");
			verify(window).evaluate(function() { return this.XMLHttpRequest.asynchrony.finished; }).is.type("function");
			
			var asynchronous = new browser.Scenario();
			
			asynchronous.name = "Browser tests for asynchronous wrapper: promises=" + PROMISES_IN_TESTS_ALLOWED;

			asynchronous.test(new function() {
				var resolve;
				var Promise_resolve;
				var chained;
				var chain = {};
				
				this.before = function(verify) {
					verify("before").is("before");
				};
				
				this.run = function() {
					if (PROMISES_IN_TESTS_ALLOWED) {
						new window.Promise(function(resolve,reject) {
							resolve("resolve");
						}).then(function(value) {
							resolve = value;
						});
						
						window.Promise.resolve("Promise.resolve").then(function(value) {
							Promise_resolve = value;
						});
						
						window.Promise.resolve("resolve").then(function(string) {
							return string + ".chain";
						}).then(function(value) {
							chained = value;
						});
						
						window.Promise.resolve().then(function() {
							chain.native = {};
							chain.native.first = true;
							return Promise.resolve();
						}).then(function() {
							chain.native.second = true;
							window.console.log("second");
							return Promise.resolve();
						}).then(function() {
							window.console.log("third");
							chain.native.third = true;
						})
					}				
				};
				
				this.after = function(verify) {
					verify("after").is("after");
					if (PROMISES_IN_TESTS_ALLOWED) {
						verify(resolve).is("resolve");
						verify(Promise_resolve).is("Promise.resolve");
						verify(chained).is("resolve.chain");
						verify(chain.native).is.type("object");
						verify(chain.native.first).is(true);
						verify(chain.native.second).is(true);
						verify(chain.native.third).is(true);
//						verify(targeted).is(30);
//						verify(chain.set).is(99);
//						verify(chain.asynchronous).is("delayed");
					}
				}
			});
			
			verify.scenario(asynchronous);
			
			if (MULTIPLE_SCENARIOS_ALLOWED) {
				var multiple = new browser.Scenario();
				multiple.name = "Browser tests: multiple scenarios via scenario.verify";

				multiple.test(new function() {
					this.after = function(verify) {
						verify("multiple").is("multiple");
					}
				});
				
				verify.scenario(multiple);
			}
		</script>
		<script type="application/x.jsapi#tests">
			if (PROMISES_IN_TESTS_ALLOWED) {
				var targeted = new browser.Scenario();
				targeted.name = "Browser tests: targeted promise";

				targeted.test(new function() {
					var result;

					this.run = function() {
						new api.Promise(function(resolve,reject) {
							resolve(42);
						}).then(function(n) {
							result = n;
						});

					}

					this.after = function(verify) {
						verify("done").is("done");
						verify(result).is(42);
					}
				});

				targeted.test(new function() {
					var targeted;

					this.run = function() {
						var target = {
							foo: 30
						};
						new api.Promise({
							target: target,
							executor: function(resolve,reject) {
								resolve(this.foo);
							}
						}).then(function(n) {
							targeted = this.foo;
						});
					};

					this.after = function(verify) {
						verify(targeted).is(30);
					}
				});

				targeted.test(new function() {
					var chain = {};

					this.run = function() {
						if (true) var ThisPromise = new api.Promise({
							target: chain,
							executor: function(resolve,reject) {
								resolve(99);
							}
						});

						if (true) var SetPromise = function() {
							return new api.Promise({
								executor: function(resolve,reject) {
									window.setTimeout(function() {
										resolve("delayed");
									}, 50);
								}
							})
						};

						if (true) ThisPromise.then(function(value) {
							this.set = value;
							return new SetPromise();
						}).then(function(delayed) {
							this.asynchronous = delayed;
						});
					};

					this.after = function(verify) {
						verify(chain.set).is(99);
						verify(chain.asynchronous).is("delayed");
					}
				});

				verify.scenario(targeted);
			}
		</script>
		<script type="application/javascript">
		</script>
		<div>__DESCRIPTION__</div>
		<div>
			<h1>Context</h1>
			<div class="type">
				<a class="type" name="types.asynchrony">asynchrony</a>
				<span>
					A type that allows this module to hook into an asynchronous processing monitor. For example, the SLIME
					browser loader allows HTTP testing with asynchronous calls; that testing framework requires that asynchronous
					code notify it of the start and end of asynchronous processes.
				</span>
				<div class="label">has properties:</div>
				<ul>
					<li class="function">
						<div class="name">started</div>
						<span>__DESCRIPTION__</span>
						<div class="arguments">
							<div class="label">Arguments</div>
							<ol>
								<li class="value">
									<span class="type">__TYPE__</span>
									<span>__DESCRIPTION__</span>
								</li>
							</ol>
						</div>
					</li>
					<li class="function">
						<div class="name">finished</div>
						<span>__DESCRIPTION__</span>
						<div class="arguments">
							<div class="label">Arguments</div>
							<ol>
								<li class="value">
									<span class="type">__TYPE__</span>
									<span>__DESCRIPTION__</span>
								</li>
							</ol>
						</div>
					</li>
				</ul>
			</div>

			<ul>
				<li class="value">
					<div class="name">Promise</div>
					<span class="type">function</span>
					<span>A constructor that can create an A+-compliant Promise.</span>
				</li>
				<li class="function">
					<div class="name">asynchrony</div>
					<div class="returns">
						<div class="label">Returns</div>
						<span class="type"><a href="#types.asynchrony">asynchrony</a></span>
					</div>
				</li>
			</ul>
		</div>
		<div>
			<h1>Exports</h1>
			<ul>
			</ul>
		</div>
	</body>
</html>